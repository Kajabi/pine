/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { BoxColumnType, BoxShadowSizeType, BoxSpacingType } from "./utils/types";
import { CheckboxChangeEventDetail } from "./components/pds-checkbox/checkbox-interface";
import { ChipSentimentType, ChipVariantType, PlacementType } from "./utils/types";
import { PdsFilterClearEventDetail, PdsFilterCloseEventDetail, PdsFilterOpenEventDetail, PdsFilterVariant } from "./components/pds-filters/pds-filter/filter-interface";
import { InputChangeEventDetail, InputInputEventDetail } from "./components/pds-input/input-interface";
import { PdsPopoverEventDetail } from "./components/pds-popover/popover-interface";
import { TextareaChangeEventDetail, TextareaInputEventDetail } from "./components/pds-textarea/textarea-interface";
export { BoxColumnType, BoxShadowSizeType, BoxSpacingType } from "./utils/types";
export { CheckboxChangeEventDetail } from "./components/pds-checkbox/checkbox-interface";
export { ChipSentimentType, ChipVariantType, PlacementType } from "./utils/types";
export { PdsFilterClearEventDetail, PdsFilterCloseEventDetail, PdsFilterOpenEventDetail, PdsFilterVariant } from "./components/pds-filters/pds-filter/filter-interface";
export { InputChangeEventDetail, InputInputEventDetail } from "./components/pds-input/input-interface";
export { PdsPopoverEventDetail } from "./components/pds-popover/popover-interface";
export { TextareaChangeEventDetail, TextareaInputEventDetail } from "./components/pds-textarea/textarea-interface";
export namespace Components {
    /**
     * Mock PdsModal component for testing purposes
     * This component mimics the real PdsModal but without using the Popover API
     */
    interface MockPdsModal {
        /**
          * Whether the modal can be dismissed by clicking the backdrop
          * @default true
         */
        "backdropDismiss": boolean;
        /**
          * The ID of the modal component
         */
        "componentId"?: string;
        /**
          * Hides the modal
         */
        "hideModal": () => Promise<void>;
        /**
          * Whether the modal is open
          * @default false
         */
        "open": boolean;
        /**
          * Whether the modal content should be scrollable
          * @default true
         */
        "scrollable": boolean;
        /**
          * Shows the modal
         */
        "showModal": () => Promise<void>;
        /**
          * The size of the modal
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg' | 'fullscreen';
    }
    interface PdsAccordion {
        /**
          * A unique identifier used for the underlying component `id` attribute.
          * @defaultValue null
         */
        "componentId": string;
        /**
          * Can be used to manually set the open state of the accordion.
          * @defaultValue false
         */
        "isOpen": boolean;
    }
    interface PdsAlert {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * If true, shows the dismiss button. If false, the dismiss button is hidden.
          * @defaultValue false
         */
        "dismissible": boolean;
        /**
          * Text displayed as the heading of the alert.
         */
        "heading": string;
        /**
          * If true, the alert is displayed in a smaller size and description text is truncated. Heading is not displayed.
          * @default false
         */
        "small": boolean;
        /**
          * Sets the style variant of the alert.
          * @defaultValue 'default'
         */
        "variant": 'default' | 'danger' | 'info' | 'success' | 'warning';
    }
    interface PdsAvatar {
        /**
          * The alt for a custom user image.
          * @defaultValue null
         */
        "alt"?: string | null;
        /**
          * Determines whether the badge is visible or not.
          * @defaultValue false
         */
        "badge"?: boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Determines whether the avatar functions as a dropdown trigger.
          * @defaultValue false
         */
        "dropdown"?: boolean;
        /**
          * The src for a custom user image.
          * @defaultValue null
         */
        "image"?: string | null;
        /**
          * Size of the avatar. Value can be preset or custom.
          * @defaultValue lg
         */
        "size"?: | 'xl' // 64px
  | 'lg' // 56px
  | 'md' // 40px
  | 'sm' // 32px
  | 'xs' // 24px
  | string;
        /**
          * Determines the variant of avatar. Changes appearance accordingly.
          * @defaultValue customer
         */
        "variant"?: 'customer' | 'admin';
    }
    interface PdsBox {
        /**
          * Defines how items within the box are aligned.
          * @defaultValue stretch
         */
        "alignItems"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how items within the box are aligned at the LG breakpoint.
          * @defaultValue stretch
         */
        "alignItemsLg"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how items within the box are aligned at the MD breakpoint.
          * @defaultValue stretch
         */
        "alignItemsMd"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how items within the box are aligned at the SM breakpoint.
          * @defaultValue stretch
         */
        "alignItemsSm"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how items within the box are aligned at the XL breakpoint.
          * @defaultValue stretch
         */
        "alignItemsXl"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how items within the box are aligned at the XS breakpoint.
          * @defaultValue stretch
         */
        "alignItemsXs"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container.
          * @defaultValue stretch
         */
        "alignSelf"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container at the LG breakpoint.
         */
        "alignSelfLg"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container at the MD breakpoint.
         */
        "alignSelfMd"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container at the SM breakpoint.
         */
        "alignSelfSm"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container at the XL breakpoint.
         */
        "alignSelfXl"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container at the XS breakpoint.
         */
        "alignSelfXs"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * If `true`, the box will be sized to fit its contents.
         */
        "auto"?: boolean;
        /**
          * If `true`, the box will be sized to fit its contents at the LG breakpoint.
         */
        "autoLg"?: boolean;
        /**
          * If `true`, the box will be sized to fit its contents at the MD breakpoint.
         */
        "autoMd"?: boolean;
        /**
          * If `true`, the box will be sized to fit its contents at the SM breakpoint.
         */
        "autoSm"?: boolean;
        /**
          * If `true`, the box will be sized to fit its contents at the XL breakpoint.
         */
        "autoXl"?: boolean;
        /**
          * If `true`, the box will be sized to fit its contents at the XS breakpoint.
         */
        "autoXs"?: boolean;
        /**
          * Defines the background-color of the box.
         */
        "backgroundColor"?: string;
        /**
          * If `true`, the box will have a border.
          * @default false
         */
        "border"?: boolean;
        /**
          * Defines the border color of the box.
         */
        "borderColor"?: string;
        /**
          * Defines how rounded the box corners are.
          * @defaultValue none
         */
        "borderRadius"?: `none` | `xs`| `sm` | `md` | `lg` | `circle`;
        /**
          * Defines the orientation of the box items.
          * @defaultValue row
         */
        "direction"?: `row` | `column`;
        /**
          * Defines the display style of the box.
          * @defaultValue flex
         */
        "display"?: `flex` | `inline-flex` | `block` | `inline-block`;
        /**
          * If `true`, sets the box `max-width` to `100%`.
         */
        "fit"?: boolean;
        /**
          * If `true`, sets the box `max-width` to `100%` at the LG breakpoint.
         */
        "fitLg"?: boolean;
        /**
          * If `true`, sets the box `max-width` to `100%` at the MD breakpoint.
         */
        "fitMd"?: boolean;
        /**
          * If `true`, sets the box `max-width` to `100%` at the SM breakpoint.
         */
        "fitSm"?: boolean;
        /**
          * If `true`, sets the box `max-width` to `100%` at the XL breakpoint.
         */
        "fitXl"?: boolean;
        /**
          * If `true`, sets the box `max-width` to `100%` at the XS breakpoint.
         */
        "fitXs"?: boolean;
        /**
          * Defines how a box will grow or shrink to fit the space available in its container. Can be a predefined value ('none', 'grow', 'shrink') or a custom flex value (e.g., '1', '0 1 auto').
          * @defaultValue none
         */
        "flex"?: `none` | `grow` | `shrink` | string;
        /**
          * Defines the spacing between the box items.
          * @defaultValue none
         */
        "gap"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the LG breakpoint.
          * @defaultValue none
         */
        "gapLg"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the MD breakpoint.
          * @defaultValue none
         */
        "gapMd"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the SM breakpoint.
          * @defaultValue none
         */
        "gapSm"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the XL breakpoint.
          * @defaultValue none
         */
        "gapXl"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the XS breakpoint.
          * @defaultValue none
         */
        "gapXs"?: BoxSpacingType;
        /**
          * Defines the horizontal alignment of the box items.
          * @defaultValue start
         */
        "justifyContent"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the horizontal alignment of the box items at the LG breakpoint.
          * @defaultValue start
         */
        "justifyContentLg"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the horizontal alignment of the box items at the MD breakpoint.
          * @defaultValue start
         */
        "justifyContentMd"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the horizontal alignment of the box items at the SM breakpoint.
          * @defaultValue start
         */
        "justifyContentSm"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the horizontal alignment of the box items at the XL breakpoint.
          * @defaultValue start
         */
        "justifyContentXl"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the horizontal alignment of the box items at the XS breakpoint.
          * @defaultValue start
         */
        "justifyContentXs"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the box's outer bottom spacing.
          * @defaultValue none
         */
        "marginBlockEnd"?: BoxSpacingType;
        /**
          * Defines the box's outer bottom spacing at the LG breakpoint.
          * @defaultValue none
         */
        "marginBlockEndLg"?: BoxSpacingType;
        /**
          * Defines the box's outer bottom spacing at the MD breakpoint.
          * @defaultValue none
         */
        "marginBlockEndMd"?: BoxSpacingType;
        /**
          * Defines the box's outer bottom spacing at the SM breakpoint.
          * @defaultValue none
         */
        "marginBlockEndSm"?: BoxSpacingType;
        /**
          * Defines the box's outer bottom spacing at the XL breakpoint.
          * @defaultValue none
         */
        "marginBlockEndXl"?: BoxSpacingType;
        /**
          * Defines the box's outer bottom spacing at the XS breakpoint.
          * @defaultValue none
         */
        "marginBlockEndXs"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing.
          * @defaultValue none
         */
        "marginBlockStart"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing at the LG breakpoint.
          * @defaultValue none
         */
        "marginBlockStartLg"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing at the MD breakpoint.
          * @defaultValue none
         */
        "marginBlockStartMd"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing at the SM breakpoint.
          * @defaultValue none
         */
        "marginBlockStartSm"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing at the XL breakpoint.
          * @defaultValue none
         */
        "marginBlockStartXl"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing at the XS breakpoint.
          * @defaultValue none
         */
        "marginBlockStartXs"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing.
          * @defaultValue none
         */
        "marginInlineEnd"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing at the LG breakpoint.
          * @defaultValue none
         */
        "marginInlineEndLg"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing at the MD breakpoint.
          * @defaultValue none
         */
        "marginInlineEndMd"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing at the SM breakpoint.
          * @defaultValue none
         */
        "marginInlineEndSm"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing at the XL breakpoint.
          * @defaultValue none
         */
        "marginInlineEndXl"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing at the XS breakpoint.
          * @defaultValue none
         */
        "marginInlineEndXs"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing.
          * @defaultValue none
         */
        "marginInlineStart"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing at the LG breakpoint.
          * @defaultValue none
         */
        "marginInlineStartLg"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing at the MD breakpoint.
          * @defaultValue none
         */
        "marginInlineStartMd"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing at the SM breakpoint.
          * @defaultValue none
         */
        "marginInlineStartSm"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing at the XL breakpoint.
          * @defaultValue none
         */
        "marginInlineStartXl"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing at the XS breakpoint.
          * @defaultValue none
         */
        "marginInlineStartXs"?: BoxSpacingType;
        /**
          * The minimum height of the row. Used in conjunction with alignment props
         */
        "minHeight"?: string;
        /**
          * The minimum width of the row. Used in conjunction with alignment props
         */
        "minWidth"?: string;
        /**
          * Move columns to the end direction of the row for all screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offset"?: BoxColumnType;
        /**
          * Move columns to the end direction of the row for `LG` screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offsetLg"?: BoxColumnType;
        /**
          * Move columns to the end direction of the row for `MD` screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offsetMd"?: BoxColumnType;
        /**
          * Move columns to the end direction of the row for `SM` screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offsetSm"?: BoxColumnType;
        /**
          * Move columns to the end direction of the row for `XL` screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offsetXl"?: BoxColumnType;
        /**
          * Move columns to the end direction of the row for `XS` screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offsetXs"?: BoxColumnType;
        /**
          * Defines the spacing between the box items.
          * @defaultValue none
         */
        "padding"?: BoxSpacingType;
        /**
          * Defines the bottom spacing.
          * @defaultValue none
         */
        "paddingBlockEnd"?: BoxSpacingType;
        /**
          * Defines the bottom spacing at the LG breakpoint.
          * @defaultValue none
         */
        "paddingBlockEndLg"?: BoxSpacingType;
        /**
          * Defines the bottom spacing at the MD breakpoint.
          * @defaultValue none
         */
        "paddingBlockEndMd"?: BoxSpacingType;
        /**
          * Defines the bottom spacing at the SM breakpoint.
          * @defaultValue none
         */
        "paddingBlockEndSm"?: BoxSpacingType;
        /**
          * Defines the bottom spacing at the XL breakpoint.
          * @defaultValue none
         */
        "paddingBlockEndXl"?: BoxSpacingType;
        /**
          * Defines the bottom spacing at the XS breakpoint.
          * @defaultValue none
         */
        "paddingBlockEndXs"?: BoxSpacingType;
        /**
          * Defines the top spacing.
          * @defaultValue none
         */
        "paddingBlockStart"?: BoxSpacingType;
        /**
          * Defines the top spacing at the LG breakpoint.
          * @defaultValue none
         */
        "paddingBlockStartLg"?: BoxSpacingType;
        /**
          * Defines the top spacing at the MD breakpoint.
          * @defaultValue none
         */
        "paddingBlockStartMd"?: BoxSpacingType;
        /**
          * Defines the top spacing at the SM breakpoint.
          * @defaultValue none
         */
        "paddingBlockStartSm"?: BoxSpacingType;
        /**
          * Defines the top spacing at the XL breakpoint.
          * @defaultValue none
         */
        "paddingBlockStartXl"?: BoxSpacingType;
        /**
          * Defines the top spacing at the XS breakpoint.
          * @defaultValue none
         */
        "paddingBlockStartXs"?: BoxSpacingType;
        /**
          * Defines the right spacing.
          * @defaultValue none
         */
        "paddingInlineEnd"?: BoxSpacingType;
        /**
          * Defines the right spacing at the LG breakpoint.
          * @defaultValue none
         */
        "paddingInlineEndLg"?: BoxSpacingType;
        /**
          * Defines the right spacing at the MD breakpoint.
          * @defaultValue none
         */
        "paddingInlineEndMd"?: BoxSpacingType;
        /**
          * Defines the right spacing at the SM breakpoint.
          * @defaultValue none
         */
        "paddingInlineEndSm"?: BoxSpacingType;
        /**
          * Defines the right spacing at the XL breakpoint.
          * @defaultValue none
         */
        "paddingInlineEndXl"?: BoxSpacingType;
        /**
          * Defines the right spacing at the XS breakpoint.
          * @defaultValue none
         */
        "paddingInlineEndXs"?: BoxSpacingType;
        /**
          * Defines the left spacing.
          * @defaultValue none
         */
        "paddingInlineStart"?: BoxSpacingType;
        /**
          * Defines the left spacing at the LG breakpoint.
          * @defaultValue none
         */
        "paddingInlineStartLg"?: BoxSpacingType;
        /**
          * Defines the left spacing at the MD breakpoint.
          * @defaultValue none
         */
        "paddingInlineStartMd"?: BoxSpacingType;
        /**
          * Defines the left spacing at the SM breakpoint.
          * @defaultValue none
         */
        "paddingInlineStartSm"?: BoxSpacingType;
        /**
          * Defines the left spacing at the XL breakpoint.
          * @defaultValue none
         */
        "paddingInlineStartXl"?: BoxSpacingType;
        /**
          * Defines the left spacing at the XS breakpoint.
          * @defaultValue none
         */
        "paddingInlineStartXs"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the LG breakpoint.
          * @defaultValue none
         */
        "paddingLg"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the MD breakpoint.
          * @defaultValue none
         */
        "paddingMd"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the SM breakpoint.
          * @defaultValue none
         */
        "paddingSm"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the XL breakpoint.
          * @defaultValue none
         */
        "paddingXl"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the XS breakpoint.
          * @defaultValue none
         */
        "paddingXs"?: BoxSpacingType;
        /**
          * Defines the box shadow.
          * @defaultValue none
         */
        "shadow"?: BoxShadowSizeType;
        /**
          * Sets the default column width for the component. This value applies from the smallest screen size (XS) upwards, unless overridden by a breakpoint-specific size prop at that breakpoint or larger.
         */
        "size"?: BoxColumnType;
        /**
          * At screen sizes from the LG breakpoint and larger (992px and up), this will take the specified number of columns. This overrides any value set by size, sizeXs, and up.
         */
        "sizeLg"?: BoxColumnType;
        /**
          * At screen sizes from the MD breakpoint and larger (768px and up), this will take the specified number of columns. This overrides any value set by size, sizeXs, and up.
         */
        "sizeMd"?: BoxColumnType;
        /**
          * At screen sizes from the SM breakpoint and larger (576px and up), this will take the specified number of columns. This overrides any value set by size or sizeXs.
         */
        "sizeSm"?: BoxColumnType;
        /**
          * At screen sizes from the XL breakpoint and larger (1200px and up), this will take the specified number of columns. This overrides any value set by size, sizeXs, and up.
         */
        "sizeXl"?: BoxColumnType;
        /**
          * At the XS breakpoint, this prop will take the number of columns specified. This overrides the base size prop for this specific range.
         */
        "sizeXs"?: BoxColumnType;
        /**
          * Defines whether flex items are forced onto one line or can wrap onto multiple lines.
          * @defaultValue false
         */
        "wrap"?: boolean;
        /**
          * Defines whether flex items can wrap onto multiple lines at the LG breakpoint.
          * @defaultValue false
         */
        "wrapLg"?: boolean;
        /**
          * Defines whether flex items can wrap onto multiple lines at the MD breakpoint.
          * @defaultValue false
         */
        "wrapMd"?: boolean;
        /**
          * Defines whether flex items can wrap onto multiple lines at the SM breakpoint.
          * @defaultValue false
         */
        "wrapSm"?: boolean;
        /**
          * Defines whether flex items can wrap onto multiple lines at the XL breakpoint.
          * @defaultValue false
         */
        "wrapXl"?: boolean;
        /**
          * Defines whether flex items can wrap onto multiple lines at the XS breakpoint.
          * @defaultValue false
         */
        "wrapXs"?: boolean;
    }
    interface PdsButton {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Determines the button's disabled state.
          * @defaultValue false
         */
        "disabled"?: boolean;
        /**
          * Determines if the button should take up the full width of its container.
          * @defaultValue false
         */
        "fullWidth"?: boolean;
        /**
          * If provided, renders the component as an anchor (`<a>`) element instead of a button. When using href, button-specific props (type, name, value, loading) will be ignored.
         */
        "href"?: string;
        /**
          * Displays a leading icon in the button. DEPRECATED.
          * @defaultValue null
          * @deprecated Use `start` slot instead.
         */
        "icon"?: string;
        /**
          * When true, displays only the icon and visually hides the text (keeping it accessible).
          * @default false
         */
        "iconOnly"?: boolean;
        /**
          * Determines if the button is in a loading state. When true, displays a loader and hides the button text.
          * @defaultValue false
         */
        "loading"?: boolean;
        /**
          * Provides the button with a submittable name.
         */
        "name"?: string;
        /**
          * Specifies where to open the linked document when href is provided. Only applies when href is set.
         */
        "target"?: '_blank' | '_self' | '_parent' | '_top';
        /**
          * Provides button with a type.
          * @defaultValue button
         */
        "type"?: 'button' | 'reset' | 'submit';
        /**
          * Provides button with a submittable value
         */
        "value"?: string;
        /**
          * Sets the style variant of the button.
          * @defaultValue primary
         */
        "variant": 'primary' | 'secondary' | 'accent' | 'disclosure' | 'destructive' | 'unstyled' | 'filter';
    }
    interface PdsCheckbox {
        /**
          * It determines whether or not the checkbox is checked.
          * @default false
         */
        "checked"?: boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute and the label `for` attribute.
         */
        "componentId": string;
        /**
          * It determines whether or not the checkbox is disabled.
         */
        "disabled": boolean;
        /**
          * Displays message text describing an invalid state.
         */
        "errorMessage": string;
        /**
          * String used for helper message below checkbox.
         */
        "helperMessage": string;
        /**
          * Visually hides the label text for instances where only the checkbox should be displayed. Label remains accessible to assistive technology such as screen readers.
         */
        "hideLabel": boolean;
        /**
          * If `true`, the checkbox will visually appear as indeterminate. Only JavaScript can set the objects `indeterminate` property. See [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#indeterminate_state_checkboxes).
         */
        "indeterminate": boolean;
        /**
          * It determines whether or not the checkbox is invalid.
         */
        "invalid": boolean;
        /**
          * String used for label text next to checkbox.
         */
        "label": string;
        /**
          * String used for checkbox `name` attribute.
         */
        "name": string;
        /**
          * It determines whether or not the checkbox is required.
         */
        "required": boolean;
        /**
          * The value of the checkbox that is submitted with a form.
         */
        "value": string;
    }
    interface PdsChip {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Determines whether a dot should be displayed on the chip. Note: This prop is ignored when sentiment is 'brand'.
          * @defaultValue false
         */
        "dot": boolean;
        /**
          * The name of the icon to display before the chip text.
         */
        "icon"?: string;
        /**
          * Determines whether the chip should be displayed in a larger size.
          * @defaultValue false
         */
        "large": boolean;
        /**
          * Defines the color scheme of the chip.
          * @defaultValue 'neutral'
         */
        "sentiment": ChipSentimentType;
        /**
          * Sets the style variant of the chip. Note: This prop is ignored when sentiment is 'brand'.
          * @defaultValue 'text'
         */
        "variant": ChipVariantType;
    }
    interface PdsCombobox {
        /**
          * Whether a dot should be displayed on the chip trigger.
          * @default false
         */
        "chipDot": boolean;
        /**
          * The name of the icon to display in the chip trigger.
         */
        "chipIcon"?: string;
        /**
          * Whether the chip trigger should be displayed in a larger size.
          * @default false
         */
        "chipLarge": boolean;
        /**
          * The sentiment for the chip trigger. Matches Pine chip sentiments.
          * @default 'neutral'
         */
        "chipSentiment": ChipSentimentType;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Enable custom layout content for options. Options with data-layout attribute will render their HTML content. ⚠️ Security Warning: Only use with trusted content. Basic XSS protection is applied, but avoid user-generated content.
          * @default false
         */
        "customOptionLayouts": boolean;
        /**
          * Enable custom layout content for the button trigger via the trigger-content slot. When true, uses slot content for initial state but updates dynamically with selected option layout. ⚠️ Security Warning: Only use with trusted content. Basic XSS protection is applied, but avoid user-generated content.
          * @default false
         */
        "customTriggerContent": boolean;
        /**
          * If true, the combobox is disabled.
          * @default false
         */
        "disabled": boolean;
        /**
          * Placement of the dropdown relative to the trigger.
          * @default 'bottom-start'
         */
        "dropdownPlacement": 'bottom-start' | 'bottom-end' | 'top-start' | 'top-end';
        /**
          * Width of the dropdown. Any valid CSS width value.
          * @default '236px'
         */
        "dropdownWidth": string;
        /**
          * Gets the value of the currently selected option.
         */
        "getSelectedValue": () => Promise<string | null>;
        /**
          * Visually hides the label text for instances where only the combobox should be displayed. Label remains accessible to assistive technology such as screen readers.
          * @default false
         */
        "hideLabel": boolean;
        /**
          * Text to be displayed as the combobox label.
         */
        "label"?: string;
        /**
          * Maximum height of the dropdown. Can be any valid CSS height value (e.g., '200px', '10rem'). When content exceeds this height, the dropdown will scroll.
         */
        "maxHeight"?: string;
        /**
          * Determines the combobox mode: 'filter' (filter options as you type) or 'select-only' (show all options).
          * @default 'filter'
         */
        "mode": 'filter' | 'select-only';
        /**
          * The name of the form control. Submitted with the form as part of a name/value pair.
         */
        "name"?: string;
        /**
          * Placeholder text for the input field.
         */
        "placeholder"?: string;
        /**
          * Sets focus on the native input element.
         */
        "setFocus": () => Promise<void>;
        /**
          * Determines the combobox trigger: 'input' (editable input), 'button' (button-like, non-editable), or 'chip' (chip-like, non-editable).
          * @default 'input'
         */
        "trigger": 'input' | 'button' | 'chip';
        /**
          * The visual variant for the button trigger. Matches Pine button variants.
          * @default 'secondary'
         */
        "triggerVariant": 'secondary' | 'primary' | 'accent' | 'destructive';
        /**
          * Width of the trigger (button or input). Any valid CSS width value.
          * @default 'fit-content'
         */
        "triggerWidth": string;
        /**
          * The value of the combobox input.
          * @default ''
         */
        "value": string;
    }
    interface PdsCopytext {
        /**
          * Determines whether `copytext` should have a visible border.
          * @defaultValue true
         */
        "border": boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Determines whether `copytext` should expand to the full width of its container.
          * @defaultValue false
         */
        "fullWidth": boolean;
        /**
          * Determines whether the `value` should truncate and display with an ellipsis.
          * @defaultValue false
         */
        "truncate": boolean;
        /**
          * The string displayed that is also copied to the clipboard upon interaction.
         */
        "value": string;
    }
    interface PdsDivider {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Adds offset margin/padding to expand the width (horizontal) or the height (vertical) of divider.
         */
        "offset": 'xxs' | 'xs' | 'sm' | 'md' | 'lg' | 'xl' | 'xxl';
        /**
          * Sets divider to display vertically.
          * @defaultValue false
         */
        "vertical": boolean;
    }
    interface PdsDropdownMenu {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * The placement of the dropdown panel relative to the trigger.
          * @default 'bottom-start'
         */
        "placement": PlacementType;
    }
    interface PdsDropdownMenuItem {
        /**
          * Trigger the click event
         */
        "clickItem": () => Promise<void>;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * It determines whether or not the dropdown-item is destructive.
          * @defaultValue false
         */
        "destructive": boolean;
        /**
          * It determines whether or not the dropdown-item is disabled.
          * @defaultValue false
         */
        "disabled": boolean;
        /**
          * If provided, renders the dropdown-item as an anchor (`<a>`) element instead of a button.
         */
        "href": string | undefined;
    }
    interface PdsDropdownMenuSeparator {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * It determines whether or not the dropdown-item is disabled.
          * @defaultValue false
         */
        "disabled": boolean;
    }
    /**
     * Individual filter component with cross-browser popover positioning.
     * Uses a hybrid approach for optimal cross-browser compatibility:
     * - Modern browsers: CSS anchor positioning + JavaScript flip classes
     * - Fallback browsers: JavaScript positioning with viewport boundary detection
     */
    interface PdsFilter {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Closes the filter popover programmatically. Note: Clear variant does not support popover functionality.
         */
        "hideFilter": () => Promise<void>;
        /**
          * The name of the icon to display in the trigger button. For 'clear' variant, this is ignored as it always shows trash icon.
         */
        "icon"?: string;
        /**
          * Opens the filter popover programmatically. Note: Clear variant does not support popover functionality.
         */
        "showFilter": () => Promise<void>;
        /**
          * The text content displayed in the trigger button.
         */
        "text"?: string;
        /**
          * The variant style of the filter trigger.
          * @defaultValue 'default'
         */
        "variant": PdsFilterVariant;
    }
    interface PdsFilters {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
    }
    interface PdsImage {
        /**
          * The image's alt tag. If none is provided, it will default to an empty string, which is desired for decorative images.
          * @defaultValue ''
         */
        "alt"?: string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * The height of the image in pixels. Setting this will devote space in the layout to prevent layout shifts when the image is loaded.
         */
        "height"?: number;
        /**
          * Indicates how the browser should load the image.
          * @defaultValue eager
         */
        "loading"?: 'eager' | 'lazy';
        /**
          * Determines the intended display size of an image within certain breakpoints. Has no effect if `srcset` is not set or value has no width descriptor.
         */
        "sizes"?: string;
        /**
          * The image's source.
         */
        "src": string;
        /**
          * A set of image sources for the browser to use for responsiveness.
         */
        "srcset"?: string;
        /**
          * The width of the image in pixels. Setting this will devote space in the layout to prevent layout shifts when the image is loaded.
         */
        "width"?: number;
    }
    interface PdsInput {
        /**
          * Specifies if and how the browser provides `autocomplete` assistance for the field.
         */
        "autocomplete": string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Sets the number of milliseconds to wait before updating the value.
         */
        "debounce"?: number;
        /**
          * Determines whether or not the input field is disabled.
         */
        "disabled"?: boolean;
        /**
          * Specifies the error message and provides an error-themed treatment to the field.
         */
        "errorMessage"?: string;
        /**
          * Determines whether or not the input field takes full width of its container.
         */
        "fullWidth"?: boolean;
        /**
          * Displays a message or hint below the input field.
         */
        "helperMessage"?: string;
        /**
          * Visually hides the label text for instances where only the input should be displayed. Label remains accessible to assistive technology such as screen readers. Note: When true, the action slot is also hidden to maintain a minimal UI.
         */
        "hideLabel": boolean;
        /**
          * Determines whether or not the input field is invalid or throws an error.
         */
        "invalid"?: boolean;
        /**
          * Text to be displayed as the input label.
         */
        "label"?: string;
        /**
          * Specifies the maximum value for the input field.
         */
        "max"?: string;
        /**
          * Specifies the maximum number of characters allowed in the input field.
         */
        "maxlength"?: string;
        /**
          * Specifies the minimum value for the input field.
         */
        "min"?: string;
        /**
          * Specifies the minimum number of characters allowed in the input field.
         */
        "minlength"?: string;
        /**
          * Specifies the name. Submitted with the form name/value pair.
         */
        "name"?: string;
        /**
          * Specifies the regular expression that the input value is checked against.
         */
        "pattern"?: string;
        /**
          * Specifies a short hint that describes the expected value of the input field.
         */
        "placeholder"?: string;
        /**
          * Determines whether or not the input field is readonly.
         */
        "readonly"?: boolean;
        /**
          * Determines whether or not the input field is required.
         */
        "required"?: boolean;
        /**
          * Sets focus on the native `input` in the `pds-input`. Use this method instead of the global `input.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * Works with the `min` and `max` attributes to define increments for the input field.
         */
        "step"?: string;
        /**
          * Determines the type of control that will be displayed `'email'`, `'number'`, `'password'`, `'tel'`, `'text'`, `'url'`
          * @defaultValue "text"
         */
        "type": string;
        /**
          * The value of the input.
          * @default ''
         */
        "value"?: string | number | null;
    }
    interface PdsLink {
        /**
          * Sets the link color.
         */
        "color"?: string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Determines whether the link should open in a new tab.
          * @defaultValue false
         */
        "external": boolean;
        /**
          * The font size of the link's text.
          * @defaultValue lg
         */
        "fontSize": 'sm' | 'md' | 'lg';
        /**
          * The hyperlink's destination URL. If no text is provided in the custom slot, the href will be used.
         */
        "href": string;
        /**
          * Sets the link variant styles.
          * @defaultValue inline
         */
        "variant": 'inline' | 'plain';
    }
    interface PdsLoader {
        /**
          * If false, the loader will be hidden.
          * @default true
         */
        "isLoading": boolean;
        /**
          * Determines whether the loader should display a label.
          * @default false
         */
        "showLabel"?: boolean;
        /**
          * Sets the size of the spinner loader. Value can be preset or custom.
          * @default 'md'
         */
        "size"?: | 'xs' // 24px
  | 'sm' // 32px
  | 'md' // 48px
  | 'lg' // 64px
  | 'xl' // 80px
  | string;
        /**
          * Determines the type of loader.
          * @default 'spinner'
         */
        "variant": 'spinner' | 'typing';
    }
    interface PdsModal {
        /**
          * Whether the modal can be dismissed by clicking the backdrop
          * @default true
         */
        "backdropDismiss": boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Closes the modal
         */
        "hideModal": () => Promise<void>;
        /**
          * Whether the modal is open
          * @default false
         */
        "open": boolean;
        /**
          * Whether the modal content should be scrollable
          * @default true
         */
        "scrollable": boolean;
        /**
          * Opens the modal
         */
        "showModal": () => Promise<void>;
        /**
          * The size of the modal
          * @default 'md'
         */
        "size": 'sm' | 'md' | 'lg' | 'fullscreen';
    }
    interface PdsModalContent {
        /**
          * The border style for the content area. When not explicitly set, automatically determined based on scroll state.
          * @default 'none'
         */
        "border": 'none' | 'both' | 'top' | 'bottom';
    }
    interface PdsModalFooter {
    }
    interface PdsModalHeader {
    }
    interface PdsPopover {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Closes the popover programmatically
         */
        "hide": () => Promise<void>;
        /**
          * Sets the maximum width of the popover content
          * @defaultValue 352
         */
        "maxWidth"?: number;
        /**
          * Determines the preferred position of the popover
          * @defaultValue "right"
         */
        "placement": PlacementType;
        /**
          * Determines the action that triggers the popover. For manual popovers, the consumer is responsible for toggling this value.
          * @defaultValue "show"
         */
        "popoverTargetAction": 'show' | 'toggle' | 'hide';
        /**
          * Determines the type of popover. Auto popovers can be "light dismissed" by clicking outside of the popover. Manual popovers require the consumer to handle the visibility of the popover.
          * @default 'auto'
         */
        "popoverType": 'auto' | 'manual';
        /**
          * Opens the popover programmatically
         */
        "show": () => Promise<void>;
        /**
          * Text that appears on the trigger element
         */
        "text": string;
        /**
          * Toggles the popover open/closed state programmatically
         */
        "toggle": () => Promise<void>;
    }
    interface PdsProgress {
        /**
          * Determines whether or not progress is animated.
          * @defaultValue false
         */
        "animated": boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute and the label `for` attribute.
         */
        "componentId": string;
        /**
          * Sets the progress fill color. Accepts a color token or a [valid color value](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value).
          * @defaultValue 'var(--pine-color-blue-300)'
         */
        "fillColor": string;
        /**
          * String used for label text. Label is visually hidden but required for better accessibility.
         */
        "label": string;
        /**
          * Sets the progress fill pecentage and visually displayed when `show-percentage=true`.
          * @defaultValue 0
         */
        "percent": number;
        /**
          * Determines whether or not the percent value should be displayed as text.
          * @defaultValue false
         */
        "showPercent": boolean;
    }
    interface PdsProperty {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * The name of the icon to display before the property text.
          * @default 'star'
         */
        "icon": string;
    }
    interface PdsRadio {
        /**
          * Determines whether or not the radio is checked.
          * @defaultValue false
         */
        "checked": boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute and the label `for` attribute.
         */
        "componentId": string;
        /**
          * Determines whether or not the radio is disabled.
          * @defaultValue false
         */
        "disabled": boolean;
        /**
          * Displays error message text describing an invalid state.
         */
        "errorMessage": string;
        /**
          * Adds a border around the radio component for better visual separation.
          * @defaultValue false
         */
        "hasBorder": boolean;
        /**
          * Displays helper message text below radio.
         */
        "helperMessage": string;
        /**
          * Visually hides the label text for instances where only the radio should be displayed. Label remains accessible to assistive technology such as screen readers.
         */
        "hideLabel": boolean;
        /**
          * Determines whether or not the radio is invalid.
          * @defaultValue false
         */
        "invalid": boolean;
        /**
          * String used for label text next to radio.
         */
        "label": string;
        /**
          * String used for radio `name` attribute.
         */
        "name": string;
        /**
          * Determines whether or not the radio is required.
          * @defaultValue false
         */
        "required": boolean;
        /**
          * The value of the radio that is submitted with a form.
         */
        "value": string;
    }
    interface PdsRow {
        /**
          * Defines the vertical alignment of the row items.
          * @defaultValue start
         */
        "alignItems"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * If `true`, the row will have a border.
          * @default false
         */
        "border"?: boolean;
        /**
          * Defines the spacing between the row items.
         */
        "colGap"?: BoxSpacingType | null;
        /**
          * Defines the spacing between the row items vertically.
         */
        "colGapBlock"?: BoxSpacingType | null;
        /**
          * Defines the spacing between the row items horizontally.
         */
        "colGapInline"?: BoxSpacingType | null;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Defines the horizontal alignment of the row items.
          * @defaultValue start
         */
        "justifyContent"?: `start` | `center` | `end` | `space-between` | `space-around`;
        /**
          * The minimum height of the row. Used in conjunction with alignment props
         */
        "minHeight"?: string;
        /**
          * If `true`, the row items will not wrap to the next line if horizontal space is not available.
          * @default false
         */
        "noWrap"?: boolean;
    }
    interface PdsSelect {
        /**
          * Specifies if and how the browser provides `autocomplete` assistance for the field.
         */
        "autocomplete": string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Indicates whether or not the select field is disabled.
          * @defaultValue false
         */
        "disabled": boolean;
        /**
          * Displays error message text describing an invalid state.
         */
        "errorMessage": string;
        /**
          * Displays helper message text below select.
         */
        "helperMessage": string;
        /**
          * Visually hides the label text for instances where only the select should be displayed. Label remains accessible to assistive technology such as screen readers. Note: When true, the action slot is also hidden to maintain a minimal UI.
         */
        "hideLabel": boolean;
        /**
          * Applies highlight styling to the select field.
         */
        "highlight"?: boolean;
        /**
          * Determines whether or not the select is invalid.
         */
        "invalid"?: boolean;
        /**
          * Text to be displayed as the select label.
         */
        "label"?: string;
        /**
          * Indicates whether multiple options can be selected.
          * @defaultValue false
         */
        "multiple": boolean;
        /**
          * Specifies the name. Submitted with the form name/value pair.
         */
        "name": string;
        /**
          * Indicates whether or not the select field is required.
          * @defaultValue false
         */
        "required": boolean;
        /**
          * The value(s) of the selected option(s).
         */
        "value"?: string | string[];
    }
    interface PdsSortable {
        /**
          * Determines whether `sortable` should have a border.
          * @defaultValue false
         */
        "border": boolean;
        /**
          * A unique identifier used for the sortable container `id` attribute.
         */
        "componentId": string;
        /**
          * Deternines whether `sortable` items should be divided with border.
          * @default false
         */
        "dividers": boolean;
        /**
          * Determines the grabbable area for the `pds-sortable-item`.
          * @default 'row'
         */
        "handleType": 'handle' | 'row';
    }
    interface PdsSortableItem {
        /**
          * A unique identifier used for the sortable item `id` attribute.
         */
        "componentId": string;
        /**
          * Determines whether `sortable-item-actions` slot should be enabled.
          * @defaultValue false
         */
        "enableActions": boolean;
        /**
          * Determines whether `sortable-item` should have a handle.
          * @defaultValue false
         */
        "showHandle": boolean;
    }
    interface PdsSwitch {
        /**
          * Determines the input 'checked' state.
          * @default false
         */
        "checked": boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute and the label `for` attribute.
         */
        "componentId": string;
        /**
          * Determines the input 'disabled' state, preventing user interaction.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Displays message text describing an invalid state.
         */
        "errorMessage"?: string;
        /**
          * Displays help text for additional description of an input.
         */
        "helperMessage": string;
        /**
          * Visually hides the label text for instances where only the switch should be displayed. Label remains accessible to assistive technology such as screen readers.
         */
        "hideLabel": boolean;
        /**
          * Determines the input 'invalid' state, signifying an error is present.
          * @default false
         */
        "invalid"?: boolean;
        /**
          * Displays text to describe the input.
         */
        "label": string;
        /**
          * Identifies form data and unifies a group of radio inputs for toggling a single property/value.
         */
        "name": string;
        /**
          * Determines the 'required' state of the input.
          * @default false
         */
        "required"?: boolean;
        /**
          * Provides input with a string submitted in form data.
         */
        "value": string;
    }
    interface PdsTab {
        "index": number;
        /**
          * Sets the related tab name, this name must match a `pds-tabpanel`'s tab name property
         */
        "name": string;
        "parentComponentId": string;
        /**
          * @default false
         */
        "selected": boolean;
        "variant": string;
    }
    interface PdsTable {
        /**
          * Determines if the table displays with reduced table cell padding.
         */
        "compact": boolean;
        /**
          * A unique identifier used for the table `id` attribute.
         */
        "componentId": string;
        /**
          * Determines if the should display a fixed first column.
         */
        "fixedColumn": boolean;
        /**
          * Enables the table to be responsive by horizontally scrolling on smaller screens.
         */
        "responsive": boolean;
        /**
          * Determines if the table displays checkboxes for selectable rows.
         */
        "selectable": boolean;
    }
    interface PdsTableBody {
    }
    interface PdsTableCell {
        /**
          * Sets the text alignment within the cell.
         */
        "cellAlign"?: 'start' | 'center' | 'end' | 'justify';
        /**
          * Truncates content to a max width of 100px and adds an ellipsis.
         */
        "truncate": boolean;
    }
    interface PdsTableHead {
        /**
          * Determines if the select all checkbox is in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Determines if the table row is currently selected.
          * @defaultValue false
         */
        "isSelected": boolean;
    }
    interface PdsTableHeadCell {
        /**
          * Sets the text alignment within the head cell.
         */
        "cellAlign"?: 'start' | 'center' | 'end' | 'justify';
        /**
          * Determines whether the table column is sortable when set to `true`.
         */
        "sortable": boolean;
    }
    interface PdsTableRow {
        /**
          * Determines if the row selected is in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Determines if the table row is currently selected.
         */
        "isSelected"?: boolean;
    }
    interface PdsTabpanel {
        /**
          * Sets the related tab name, this name must match a `pds-tab`'s tab name property
         */
        "name": string;
        "parentComponentId": string;
        /**
          * @default false
         */
        "selected": boolean;
        "variant": string;
    }
    interface PdsTabs {
        "activeTabIndex": number;
        /**
          * Sets the starting active tab name and maintains the name as the component re-renders
         */
        "activeTabName": string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Sets the aria-label attached to the tablist element
         */
        "tablistLabel": string;
        /**
          * Sets tabs variant styles as outlined in Figma documentation
         */
        "variant": 'primary' | 'availability' | 'filter' | 'pill';
    }
    interface PdsText {
        /**
          * Sets the text alignment.
         */
        "align"?: 'start' | 'center' | 'end' | 'justify';
        /**
          * Sets the text color.
         */
        "color"?: string;
        /**
          * Sets the text decoration.
         */
        "decoration"?: | 'strikethrough'
  | 'underline-dotted';
        /**
          * Set the bottom margin for the text.
         */
        "gutter"?: | '2xl'
  | 'xl'
  | 'lg'
  | 'md'
  | 'sm'
  | 'xs'
  | '2xs';
        /**
          * If set or `true`, the text will be italic.
         */
        "italic"?: boolean;
        /**
          * Sets the font size.
         */
        "size"?: | '2xl'
  | 'xl'
  | 'lg'
  | 'md'
  | 'sm'
  | 'xs'
  | '2xs'
  | 'h1'
  | 'h2'
  | 'h3'
  | 'h4'
  | 'h5'
  | 'h6';
        /**
          * Determines what semantic text tag to render.
          * @default "p"
         */
        "tag": | 'h1'
  | 'h2'
  | 'h3'
  | 'h4'
  | 'h5'
  | 'h6'
  | 'p'
  | 'code'
  | 'pre'
  | 'strong'
  | 'em';
        /**
          * If set or `true`, the text will be truncated. Must add a `width` to the element.
         */
        "truncate"?: boolean;
        /**
          * Sets the font weight.
         */
        "weight"?: | 'extra-light'
  | 'light'
  | 'regular'
  | 'medium'
  | 'semibold'
  | 'bold';
    }
    interface PdsTextarea {
        /**
          * Specifies if and how the browser provides `autocomplete` assistance for the field.
         */
        "autocomplete": string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * The amount of time, in milliseconds, to wait to trigger the event after each keystroke.
         */
        "debounce"?: number;
        /**
          * Determines whether or not the textarea is disabled.
          * @defaultValue false
         */
        "disabled": boolean;
        /**
          * Displays an error message below the textarea field.
         */
        "errorMessage"?: string;
        /**
          * Displays a message or hint below the textarea field.
         */
        "helperMessage"?: string;
        /**
          * Visually hides the label text for instances where only the textarea should be displayed. Label remains accessible to assistive technology such as screen readers. Note: When true, the action slot is also hidden to maintain a minimal UI.
         */
        "hideLabel": boolean;
        /**
          * Determines whether or not the textarea is invalid or throws an error.
          * @defaultValue false
         */
        "invalid": boolean;
        /**
          * Text to be displayed as the textarea label.
         */
        "label"?: string;
        /**
          * Specifies the maximum number of characters allowed in the textarea. When set, displays a character counter.
         */
        "maxLength"?: number;
        /**
          * Specifies the name. Submitted with the form name/value pair. This value will mirror the componentId.
          * @default this.componentId
         */
        "name": string;
        /**
          * Specifies a short hint that describes the expected value of the textarea.
         */
        "placeholder"?: string;
        /**
          * Determines whether or not the textarea is readonly.
          * @defaultValue false
         */
        "readonly": boolean;
        /**
          * Determines whether or not the textarea is required.
          * @defaultValue false
         */
        "required": boolean;
        /**
          * Sets number of rows of text visible without needing to scroll in the textarea.
         */
        "rows"?: number;
        /**
          * Sets focus on the native `textarea` in the `pds-textarea`. Use this method instead of the global `textarea.focus()`.
         */
        "setFocus": () => Promise<void>;
        /**
          * The value of the textarea.
          * @default ''
         */
        "value"?: string | null;
    }
    interface PdsToast {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        "dismiss": () => Promise<void>;
        /**
          * Whether the toast can be dismissed manually via the close button. Note: This only controls manual dismissal. Auto-dismissal via duration still applies.
          * @default true
         */
        "dismissible": boolean;
        /**
          * The duration in milliseconds to show the toast before auto-dismissing. Set to 0 to disable auto-dismiss.
          * @default 4500
         */
        "duration": number;
        /**
          * The name of the icon to display in the toast.
         */
        "icon"?: string;
        /**
          * The type of toast to display. - default: Grey background (default) - danger: Red background - loading: With spinner animation
          * @default 'default'
         */
        "type": 'default' | 'danger' | 'loading';
    }
    interface PdsTooltip {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Content for the tooltip. If HTML is required, use the content slot
         */
        "content": string;
        /**
          * Determines whether or not the tooltip has an arrow
          * @defaultValue true
         */
        "hasArrow": boolean;
        /**
          * Hides the tooltip by disabling the opened property
         */
        "hideTooltip": () => Promise<void>;
        /**
          * Enable this option when using the content slot
          * @defaultValue false
         */
        "htmlContent": boolean;
        /**
          * Sets the maximum width of the tooltip content
          * @defaultValue "352px"
         */
        "maxWidth": string;
        /**
          * Determines whether or not the tooltip is visible
          * @defaultValue false
         */
        "opened": boolean;
        /**
          * Determines the preferred position of the tooltip
          * @defaultValue "right"
         */
        "placement": PlacementType;
        /**
          * Shows the tooltip by enabling the opened property
         */
        "showTooltip": () => Promise<void>;
    }
}
export interface MockPdsModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLMockPdsModalElement;
}
export interface PdsAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsAlertElement;
}
export interface PdsButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsButtonElement;
}
export interface PdsCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsCheckboxElement;
}
export interface PdsChipCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsChipElement;
}
export interface PdsComboboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsComboboxElement;
}
export interface PdsCopytextCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsCopytextElement;
}
export interface PdsDropdownMenuItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsDropdownMenuItemElement;
}
export interface PdsFilterCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsFilterElement;
}
export interface PdsInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsInputElement;
}
export interface PdsModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsModalElement;
}
export interface PdsPopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsPopoverElement;
}
export interface PdsRadioCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsRadioElement;
}
export interface PdsSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsSelectElement;
}
export interface PdsSortableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsSortableElement;
}
export interface PdsSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsSwitchElement;
}
export interface PdsTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsTabElement;
}
export interface PdsTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsTableElement;
}
export interface PdsTableHeadCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsTableHeadElement;
}
export interface PdsTableHeadCellCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsTableHeadCellElement;
}
export interface PdsTableRowCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsTableRowElement;
}
export interface PdsTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsTextareaElement;
}
export interface PdsToastCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPdsToastElement;
}
declare global {
    interface HTMLMockPdsModalElementEventMap {
        "pdsModalOpen": any;
        "pdsModalClose": any;
        "pdsModalBackdropClick": any;
    }
    /**
     * Mock PdsModal component for testing purposes
     * This component mimics the real PdsModal but without using the Popover API
     */
    interface HTMLMockPdsModalElement extends Components.MockPdsModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLMockPdsModalElementEventMap>(type: K, listener: (this: HTMLMockPdsModalElement, ev: MockPdsModalCustomEvent<HTMLMockPdsModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLMockPdsModalElementEventMap>(type: K, listener: (this: HTMLMockPdsModalElement, ev: MockPdsModalCustomEvent<HTMLMockPdsModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLMockPdsModalElement: {
        prototype: HTMLMockPdsModalElement;
        new (): HTMLMockPdsModalElement;
    };
    interface HTMLPdsAccordionElement extends Components.PdsAccordion, HTMLStencilElement {
    }
    var HTMLPdsAccordionElement: {
        prototype: HTMLPdsAccordionElement;
        new (): HTMLPdsAccordionElement;
    };
    interface HTMLPdsAlertElementEventMap {
        "pdsAlertDismissClick": void;
    }
    interface HTMLPdsAlertElement extends Components.PdsAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsAlertElementEventMap>(type: K, listener: (this: HTMLPdsAlertElement, ev: PdsAlertCustomEvent<HTMLPdsAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsAlertElementEventMap>(type: K, listener: (this: HTMLPdsAlertElement, ev: PdsAlertCustomEvent<HTMLPdsAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsAlertElement: {
        prototype: HTMLPdsAlertElement;
        new (): HTMLPdsAlertElement;
    };
    interface HTMLPdsAvatarElement extends Components.PdsAvatar, HTMLStencilElement {
    }
    var HTMLPdsAvatarElement: {
        prototype: HTMLPdsAvatarElement;
        new (): HTMLPdsAvatarElement;
    };
    interface HTMLPdsBoxElement extends Components.PdsBox, HTMLStencilElement {
    }
    var HTMLPdsBoxElement: {
        prototype: HTMLPdsBoxElement;
        new (): HTMLPdsBoxElement;
    };
    interface HTMLPdsButtonElementEventMap {
        "pdsClick": any;
    }
    interface HTMLPdsButtonElement extends Components.PdsButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsButtonElementEventMap>(type: K, listener: (this: HTMLPdsButtonElement, ev: PdsButtonCustomEvent<HTMLPdsButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsButtonElementEventMap>(type: K, listener: (this: HTMLPdsButtonElement, ev: PdsButtonCustomEvent<HTMLPdsButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsButtonElement: {
        prototype: HTMLPdsButtonElement;
        new (): HTMLPdsButtonElement;
    };
    interface HTMLPdsCheckboxElementEventMap {
        "pdsCheckboxChange": CheckboxChangeEventDetail;
        "pdsCheckboxInput": CheckboxChangeEventDetail;
    }
    interface HTMLPdsCheckboxElement extends Components.PdsCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsCheckboxElementEventMap>(type: K, listener: (this: HTMLPdsCheckboxElement, ev: PdsCheckboxCustomEvent<HTMLPdsCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsCheckboxElementEventMap>(type: K, listener: (this: HTMLPdsCheckboxElement, ev: PdsCheckboxCustomEvent<HTMLPdsCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsCheckboxElement: {
        prototype: HTMLPdsCheckboxElement;
        new (): HTMLPdsCheckboxElement;
    };
    interface HTMLPdsChipElementEventMap {
        "pdsTagCloseClick": any;
    }
    interface HTMLPdsChipElement extends Components.PdsChip, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsChipElementEventMap>(type: K, listener: (this: HTMLPdsChipElement, ev: PdsChipCustomEvent<HTMLPdsChipElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsChipElementEventMap>(type: K, listener: (this: HTMLPdsChipElement, ev: PdsChipCustomEvent<HTMLPdsChipElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsChipElement: {
        prototype: HTMLPdsChipElement;
        new (): HTMLPdsChipElement;
    };
    interface HTMLPdsComboboxElementEventMap {
        "pdsComboboxChange": { value: string };
    }
    interface HTMLPdsComboboxElement extends Components.PdsCombobox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsComboboxElementEventMap>(type: K, listener: (this: HTMLPdsComboboxElement, ev: PdsComboboxCustomEvent<HTMLPdsComboboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsComboboxElementEventMap>(type: K, listener: (this: HTMLPdsComboboxElement, ev: PdsComboboxCustomEvent<HTMLPdsComboboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsComboboxElement: {
        prototype: HTMLPdsComboboxElement;
        new (): HTMLPdsComboboxElement;
    };
    interface HTMLPdsCopytextElementEventMap {
        "pdsCopyTextClick": any;
    }
    interface HTMLPdsCopytextElement extends Components.PdsCopytext, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsCopytextElementEventMap>(type: K, listener: (this: HTMLPdsCopytextElement, ev: PdsCopytextCustomEvent<HTMLPdsCopytextElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsCopytextElementEventMap>(type: K, listener: (this: HTMLPdsCopytextElement, ev: PdsCopytextCustomEvent<HTMLPdsCopytextElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsCopytextElement: {
        prototype: HTMLPdsCopytextElement;
        new (): HTMLPdsCopytextElement;
    };
    interface HTMLPdsDividerElement extends Components.PdsDivider, HTMLStencilElement {
    }
    var HTMLPdsDividerElement: {
        prototype: HTMLPdsDividerElement;
        new (): HTMLPdsDividerElement;
    };
    interface HTMLPdsDropdownMenuElement extends Components.PdsDropdownMenu, HTMLStencilElement {
    }
    var HTMLPdsDropdownMenuElement: {
        prototype: HTMLPdsDropdownMenuElement;
        new (): HTMLPdsDropdownMenuElement;
    };
    interface HTMLPdsDropdownMenuItemElementEventMap {
        "pdsClick": {itemIndex: number, item: HTMLPdsDropdownMenuItemElement, content: string};
    }
    interface HTMLPdsDropdownMenuItemElement extends Components.PdsDropdownMenuItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsDropdownMenuItemElementEventMap>(type: K, listener: (this: HTMLPdsDropdownMenuItemElement, ev: PdsDropdownMenuItemCustomEvent<HTMLPdsDropdownMenuItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsDropdownMenuItemElementEventMap>(type: K, listener: (this: HTMLPdsDropdownMenuItemElement, ev: PdsDropdownMenuItemCustomEvent<HTMLPdsDropdownMenuItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsDropdownMenuItemElement: {
        prototype: HTMLPdsDropdownMenuItemElement;
        new (): HTMLPdsDropdownMenuItemElement;
    };
    interface HTMLPdsDropdownMenuSeparatorElement extends Components.PdsDropdownMenuSeparator, HTMLStencilElement {
    }
    var HTMLPdsDropdownMenuSeparatorElement: {
        prototype: HTMLPdsDropdownMenuSeparatorElement;
        new (): HTMLPdsDropdownMenuSeparatorElement;
    };
    interface HTMLPdsFilterElementEventMap {
        "pdsFilterOpen": PdsFilterOpenEventDetail;
        "pdsFilterClose": PdsFilterCloseEventDetail;
        "pdsFilterClear": PdsFilterClearEventDetail;
    }
    /**
     * Individual filter component with cross-browser popover positioning.
     * Uses a hybrid approach for optimal cross-browser compatibility:
     * - Modern browsers: CSS anchor positioning + JavaScript flip classes
     * - Fallback browsers: JavaScript positioning with viewport boundary detection
     */
    interface HTMLPdsFilterElement extends Components.PdsFilter, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsFilterElementEventMap>(type: K, listener: (this: HTMLPdsFilterElement, ev: PdsFilterCustomEvent<HTMLPdsFilterElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsFilterElementEventMap>(type: K, listener: (this: HTMLPdsFilterElement, ev: PdsFilterCustomEvent<HTMLPdsFilterElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsFilterElement: {
        prototype: HTMLPdsFilterElement;
        new (): HTMLPdsFilterElement;
    };
    interface HTMLPdsFiltersElement extends Components.PdsFilters, HTMLStencilElement {
    }
    var HTMLPdsFiltersElement: {
        prototype: HTMLPdsFiltersElement;
        new (): HTMLPdsFiltersElement;
    };
    interface HTMLPdsImageElement extends Components.PdsImage, HTMLStencilElement {
    }
    var HTMLPdsImageElement: {
        prototype: HTMLPdsImageElement;
        new (): HTMLPdsImageElement;
    };
    interface HTMLPdsInputElementEventMap {
        "pdsBlur": FocusEvent;
        "pdsChange": InputChangeEventDetail;
        "pdsFocus": FocusEvent;
        "pdsInput": InputInputEventDetail;
    }
    interface HTMLPdsInputElement extends Components.PdsInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsInputElementEventMap>(type: K, listener: (this: HTMLPdsInputElement, ev: PdsInputCustomEvent<HTMLPdsInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsInputElementEventMap>(type: K, listener: (this: HTMLPdsInputElement, ev: PdsInputCustomEvent<HTMLPdsInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsInputElement: {
        prototype: HTMLPdsInputElement;
        new (): HTMLPdsInputElement;
    };
    interface HTMLPdsLinkElement extends Components.PdsLink, HTMLStencilElement {
    }
    var HTMLPdsLinkElement: {
        prototype: HTMLPdsLinkElement;
        new (): HTMLPdsLinkElement;
    };
    interface HTMLPdsLoaderElement extends Components.PdsLoader, HTMLStencilElement {
    }
    var HTMLPdsLoaderElement: {
        prototype: HTMLPdsLoaderElement;
        new (): HTMLPdsLoaderElement;
    };
    interface HTMLPdsModalElementEventMap {
        "pdsModalOpen": void;
        "pdsModalClose": void;
    }
    interface HTMLPdsModalElement extends Components.PdsModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsModalElementEventMap>(type: K, listener: (this: HTMLPdsModalElement, ev: PdsModalCustomEvent<HTMLPdsModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsModalElementEventMap>(type: K, listener: (this: HTMLPdsModalElement, ev: PdsModalCustomEvent<HTMLPdsModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsModalElement: {
        prototype: HTMLPdsModalElement;
        new (): HTMLPdsModalElement;
    };
    interface HTMLPdsModalContentElement extends Components.PdsModalContent, HTMLStencilElement {
    }
    var HTMLPdsModalContentElement: {
        prototype: HTMLPdsModalContentElement;
        new (): HTMLPdsModalContentElement;
    };
    interface HTMLPdsModalFooterElement extends Components.PdsModalFooter, HTMLStencilElement {
    }
    var HTMLPdsModalFooterElement: {
        prototype: HTMLPdsModalFooterElement;
        new (): HTMLPdsModalFooterElement;
    };
    interface HTMLPdsModalHeaderElement extends Components.PdsModalHeader, HTMLStencilElement {
    }
    var HTMLPdsModalHeaderElement: {
        prototype: HTMLPdsModalHeaderElement;
        new (): HTMLPdsModalHeaderElement;
    };
    interface HTMLPdsPopoverElementEventMap {
        "pdsPopoverOpen": PdsPopoverEventDetail;
        "pdsPopoverClose": PdsPopoverEventDetail;
    }
    interface HTMLPdsPopoverElement extends Components.PdsPopover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsPopoverElementEventMap>(type: K, listener: (this: HTMLPdsPopoverElement, ev: PdsPopoverCustomEvent<HTMLPdsPopoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsPopoverElementEventMap>(type: K, listener: (this: HTMLPdsPopoverElement, ev: PdsPopoverCustomEvent<HTMLPdsPopoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsPopoverElement: {
        prototype: HTMLPdsPopoverElement;
        new (): HTMLPdsPopoverElement;
    };
    interface HTMLPdsProgressElement extends Components.PdsProgress, HTMLStencilElement {
    }
    var HTMLPdsProgressElement: {
        prototype: HTMLPdsProgressElement;
        new (): HTMLPdsProgressElement;
    };
    interface HTMLPdsPropertyElement extends Components.PdsProperty, HTMLStencilElement {
    }
    var HTMLPdsPropertyElement: {
        prototype: HTMLPdsPropertyElement;
        new (): HTMLPdsPropertyElement;
    };
    interface HTMLPdsRadioElementEventMap {
        "pdsRadioChange": boolean;
    }
    interface HTMLPdsRadioElement extends Components.PdsRadio, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsRadioElementEventMap>(type: K, listener: (this: HTMLPdsRadioElement, ev: PdsRadioCustomEvent<HTMLPdsRadioElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsRadioElementEventMap>(type: K, listener: (this: HTMLPdsRadioElement, ev: PdsRadioCustomEvent<HTMLPdsRadioElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsRadioElement: {
        prototype: HTMLPdsRadioElement;
        new (): HTMLPdsRadioElement;
    };
    interface HTMLPdsRowElement extends Components.PdsRow, HTMLStencilElement {
    }
    var HTMLPdsRowElement: {
        prototype: HTMLPdsRowElement;
        new (): HTMLPdsRowElement;
    };
    interface HTMLPdsSelectElementEventMap {
        "pdsSelectChange": InputEvent;
    }
    interface HTMLPdsSelectElement extends Components.PdsSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsSelectElementEventMap>(type: K, listener: (this: HTMLPdsSelectElement, ev: PdsSelectCustomEvent<HTMLPdsSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsSelectElementEventMap>(type: K, listener: (this: HTMLPdsSelectElement, ev: PdsSelectCustomEvent<HTMLPdsSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsSelectElement: {
        prototype: HTMLPdsSelectElement;
        new (): HTMLPdsSelectElement;
    };
    interface HTMLPdsSortableElementEventMap {
        "pdsSortableItemMoved": any;
    }
    interface HTMLPdsSortableElement extends Components.PdsSortable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsSortableElementEventMap>(type: K, listener: (this: HTMLPdsSortableElement, ev: PdsSortableCustomEvent<HTMLPdsSortableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsSortableElementEventMap>(type: K, listener: (this: HTMLPdsSortableElement, ev: PdsSortableCustomEvent<HTMLPdsSortableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsSortableElement: {
        prototype: HTMLPdsSortableElement;
        new (): HTMLPdsSortableElement;
    };
    interface HTMLPdsSortableItemElement extends Components.PdsSortableItem, HTMLStencilElement {
    }
    var HTMLPdsSortableItemElement: {
        prototype: HTMLPdsSortableItemElement;
        new (): HTMLPdsSortableItemElement;
    };
    interface HTMLPdsSwitchElementEventMap {
        "pdsSwitchChange": InputEvent;
    }
    interface HTMLPdsSwitchElement extends Components.PdsSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsSwitchElementEventMap>(type: K, listener: (this: HTMLPdsSwitchElement, ev: PdsSwitchCustomEvent<HTMLPdsSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsSwitchElementEventMap>(type: K, listener: (this: HTMLPdsSwitchElement, ev: PdsSwitchCustomEvent<HTMLPdsSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsSwitchElement: {
        prototype: HTMLPdsSwitchElement;
        new (): HTMLPdsSwitchElement;
    };
    interface HTMLPdsTabElementEventMap {
        "pdsTabClick": object;
    }
    interface HTMLPdsTabElement extends Components.PdsTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsTabElementEventMap>(type: K, listener: (this: HTMLPdsTabElement, ev: PdsTabCustomEvent<HTMLPdsTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsTabElementEventMap>(type: K, listener: (this: HTMLPdsTabElement, ev: PdsTabCustomEvent<HTMLPdsTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsTabElement: {
        prototype: HTMLPdsTabElement;
        new (): HTMLPdsTabElement;
    };
    interface HTMLPdsTableElementEventMap {
        "pdsTableSelect": { rowIndex: number; isSelected: boolean };
        "pdsTableSelectAll": { isSelected: boolean };
    }
    interface HTMLPdsTableElement extends Components.PdsTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsTableElementEventMap>(type: K, listener: (this: HTMLPdsTableElement, ev: PdsTableCustomEvent<HTMLPdsTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsTableElementEventMap>(type: K, listener: (this: HTMLPdsTableElement, ev: PdsTableCustomEvent<HTMLPdsTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsTableElement: {
        prototype: HTMLPdsTableElement;
        new (): HTMLPdsTableElement;
    };
    interface HTMLPdsTableBodyElement extends Components.PdsTableBody, HTMLStencilElement {
    }
    var HTMLPdsTableBodyElement: {
        prototype: HTMLPdsTableBodyElement;
        new (): HTMLPdsTableBodyElement;
    };
    interface HTMLPdsTableCellElement extends Components.PdsTableCell, HTMLStencilElement {
    }
    var HTMLPdsTableCellElement: {
        prototype: HTMLPdsTableCellElement;
        new (): HTMLPdsTableCellElement;
    };
    interface HTMLPdsTableHeadElementEventMap {
        "pdsTableSelectAll": { isSelected: boolean };
    }
    interface HTMLPdsTableHeadElement extends Components.PdsTableHead, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsTableHeadElementEventMap>(type: K, listener: (this: HTMLPdsTableHeadElement, ev: PdsTableHeadCustomEvent<HTMLPdsTableHeadElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsTableHeadElementEventMap>(type: K, listener: (this: HTMLPdsTableHeadElement, ev: PdsTableHeadCustomEvent<HTMLPdsTableHeadElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsTableHeadElement: {
        prototype: HTMLPdsTableHeadElement;
        new (): HTMLPdsTableHeadElement;
    };
    interface HTMLPdsTableHeadCellElementEventMap {
        "pdsTableSort": { column: string; direction: string };
    }
    interface HTMLPdsTableHeadCellElement extends Components.PdsTableHeadCell, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsTableHeadCellElementEventMap>(type: K, listener: (this: HTMLPdsTableHeadCellElement, ev: PdsTableHeadCellCustomEvent<HTMLPdsTableHeadCellElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsTableHeadCellElementEventMap>(type: K, listener: (this: HTMLPdsTableHeadCellElement, ev: PdsTableHeadCellCustomEvent<HTMLPdsTableHeadCellElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsTableHeadCellElement: {
        prototype: HTMLPdsTableHeadCellElement;
        new (): HTMLPdsTableHeadCellElement;
    };
    interface HTMLPdsTableRowElementEventMap {
        "pdsTableRowSelected": { rowIndex: number; isSelected: boolean; };
    }
    interface HTMLPdsTableRowElement extends Components.PdsTableRow, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsTableRowElementEventMap>(type: K, listener: (this: HTMLPdsTableRowElement, ev: PdsTableRowCustomEvent<HTMLPdsTableRowElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsTableRowElementEventMap>(type: K, listener: (this: HTMLPdsTableRowElement, ev: PdsTableRowCustomEvent<HTMLPdsTableRowElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsTableRowElement: {
        prototype: HTMLPdsTableRowElement;
        new (): HTMLPdsTableRowElement;
    };
    interface HTMLPdsTabpanelElement extends Components.PdsTabpanel, HTMLStencilElement {
    }
    var HTMLPdsTabpanelElement: {
        prototype: HTMLPdsTabpanelElement;
        new (): HTMLPdsTabpanelElement;
    };
    interface HTMLPdsTabsElement extends Components.PdsTabs, HTMLStencilElement {
    }
    var HTMLPdsTabsElement: {
        prototype: HTMLPdsTabsElement;
        new (): HTMLPdsTabsElement;
    };
    interface HTMLPdsTextElement extends Components.PdsText, HTMLStencilElement {
    }
    var HTMLPdsTextElement: {
        prototype: HTMLPdsTextElement;
        new (): HTMLPdsTextElement;
    };
    interface HTMLPdsTextareaElementEventMap {
        "pdsBlur": FocusEvent;
        "pdsFocus": FocusEvent;
        "pdsInput": TextareaInputEventDetail;
        "pdsTextareaChange": TextareaChangeEventDetail;
    }
    interface HTMLPdsTextareaElement extends Components.PdsTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsTextareaElementEventMap>(type: K, listener: (this: HTMLPdsTextareaElement, ev: PdsTextareaCustomEvent<HTMLPdsTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsTextareaElementEventMap>(type: K, listener: (this: HTMLPdsTextareaElement, ev: PdsTextareaCustomEvent<HTMLPdsTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsTextareaElement: {
        prototype: HTMLPdsTextareaElement;
        new (): HTMLPdsTextareaElement;
    };
    interface HTMLPdsToastElementEventMap {
        "pdsToastDismissed": { componentId?: string };
    }
    interface HTMLPdsToastElement extends Components.PdsToast, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPdsToastElementEventMap>(type: K, listener: (this: HTMLPdsToastElement, ev: PdsToastCustomEvent<HTMLPdsToastElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPdsToastElementEventMap>(type: K, listener: (this: HTMLPdsToastElement, ev: PdsToastCustomEvent<HTMLPdsToastElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPdsToastElement: {
        prototype: HTMLPdsToastElement;
        new (): HTMLPdsToastElement;
    };
    interface HTMLPdsTooltipElement extends Components.PdsTooltip, HTMLStencilElement {
    }
    var HTMLPdsTooltipElement: {
        prototype: HTMLPdsTooltipElement;
        new (): HTMLPdsTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "mock-pds-modal": HTMLMockPdsModalElement;
        "pds-accordion": HTMLPdsAccordionElement;
        "pds-alert": HTMLPdsAlertElement;
        "pds-avatar": HTMLPdsAvatarElement;
        "pds-box": HTMLPdsBoxElement;
        "pds-button": HTMLPdsButtonElement;
        "pds-checkbox": HTMLPdsCheckboxElement;
        "pds-chip": HTMLPdsChipElement;
        "pds-combobox": HTMLPdsComboboxElement;
        "pds-copytext": HTMLPdsCopytextElement;
        "pds-divider": HTMLPdsDividerElement;
        "pds-dropdown-menu": HTMLPdsDropdownMenuElement;
        "pds-dropdown-menu-item": HTMLPdsDropdownMenuItemElement;
        "pds-dropdown-menu-separator": HTMLPdsDropdownMenuSeparatorElement;
        "pds-filter": HTMLPdsFilterElement;
        "pds-filters": HTMLPdsFiltersElement;
        "pds-image": HTMLPdsImageElement;
        "pds-input": HTMLPdsInputElement;
        "pds-link": HTMLPdsLinkElement;
        "pds-loader": HTMLPdsLoaderElement;
        "pds-modal": HTMLPdsModalElement;
        "pds-modal-content": HTMLPdsModalContentElement;
        "pds-modal-footer": HTMLPdsModalFooterElement;
        "pds-modal-header": HTMLPdsModalHeaderElement;
        "pds-popover": HTMLPdsPopoverElement;
        "pds-progress": HTMLPdsProgressElement;
        "pds-property": HTMLPdsPropertyElement;
        "pds-radio": HTMLPdsRadioElement;
        "pds-row": HTMLPdsRowElement;
        "pds-select": HTMLPdsSelectElement;
        "pds-sortable": HTMLPdsSortableElement;
        "pds-sortable-item": HTMLPdsSortableItemElement;
        "pds-switch": HTMLPdsSwitchElement;
        "pds-tab": HTMLPdsTabElement;
        "pds-table": HTMLPdsTableElement;
        "pds-table-body": HTMLPdsTableBodyElement;
        "pds-table-cell": HTMLPdsTableCellElement;
        "pds-table-head": HTMLPdsTableHeadElement;
        "pds-table-head-cell": HTMLPdsTableHeadCellElement;
        "pds-table-row": HTMLPdsTableRowElement;
        "pds-tabpanel": HTMLPdsTabpanelElement;
        "pds-tabs": HTMLPdsTabsElement;
        "pds-text": HTMLPdsTextElement;
        "pds-textarea": HTMLPdsTextareaElement;
        "pds-toast": HTMLPdsToastElement;
        "pds-tooltip": HTMLPdsTooltipElement;
    }
}
declare namespace LocalJSX {
    /**
     * Mock PdsModal component for testing purposes
     * This component mimics the real PdsModal but without using the Popover API
     */
    interface MockPdsModal {
        /**
          * Whether the modal can be dismissed by clicking the backdrop
          * @default true
         */
        "backdropDismiss"?: boolean;
        /**
          * The ID of the modal component
         */
        "componentId"?: string;
        /**
          * Event emitted when the backdrop is clicked
         */
        "onPdsModalBackdropClick"?: (event: MockPdsModalCustomEvent<any>) => void;
        /**
          * Event emitted when the modal is closed
         */
        "onPdsModalClose"?: (event: MockPdsModalCustomEvent<any>) => void;
        /**
          * Event emitted when the modal is opened
         */
        "onPdsModalOpen"?: (event: MockPdsModalCustomEvent<any>) => void;
        /**
          * Whether the modal is open
          * @default false
         */
        "open"?: boolean;
        /**
          * Whether the modal content should be scrollable
          * @default true
         */
        "scrollable"?: boolean;
        /**
          * The size of the modal
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg' | 'fullscreen';
    }
    interface PdsAccordion {
        /**
          * A unique identifier used for the underlying component `id` attribute.
          * @defaultValue null
         */
        "componentId"?: string;
        /**
          * Can be used to manually set the open state of the accordion.
          * @defaultValue false
         */
        "isOpen"?: boolean;
    }
    interface PdsAlert {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * If true, shows the dismiss button. If false, the dismiss button is hidden.
          * @defaultValue false
         */
        "dismissible"?: boolean;
        /**
          * Text displayed as the heading of the alert.
         */
        "heading"?: string;
        /**
          * Event emitted when the dismiss button is clicked.
         */
        "onPdsAlertDismissClick"?: (event: PdsAlertCustomEvent<void>) => void;
        /**
          * If true, the alert is displayed in a smaller size and description text is truncated. Heading is not displayed.
          * @default false
         */
        "small"?: boolean;
        /**
          * Sets the style variant of the alert.
          * @defaultValue 'default'
         */
        "variant"?: 'default' | 'danger' | 'info' | 'success' | 'warning';
    }
    interface PdsAvatar {
        /**
          * The alt for a custom user image.
          * @defaultValue null
         */
        "alt"?: string | null;
        /**
          * Determines whether the badge is visible or not.
          * @defaultValue false
         */
        "badge"?: boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * Determines whether the avatar functions as a dropdown trigger.
          * @defaultValue false
         */
        "dropdown"?: boolean;
        /**
          * The src for a custom user image.
          * @defaultValue null
         */
        "image"?: string | null;
        /**
          * Size of the avatar. Value can be preset or custom.
          * @defaultValue lg
         */
        "size"?: | 'xl' // 64px
  | 'lg' // 56px
  | 'md' // 40px
  | 'sm' // 32px
  | 'xs' // 24px
  | string;
        /**
          * Determines the variant of avatar. Changes appearance accordingly.
          * @defaultValue customer
         */
        "variant"?: 'customer' | 'admin';
    }
    interface PdsBox {
        /**
          * Defines how items within the box are aligned.
          * @defaultValue stretch
         */
        "alignItems"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how items within the box are aligned at the LG breakpoint.
          * @defaultValue stretch
         */
        "alignItemsLg"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how items within the box are aligned at the MD breakpoint.
          * @defaultValue stretch
         */
        "alignItemsMd"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how items within the box are aligned at the SM breakpoint.
          * @defaultValue stretch
         */
        "alignItemsSm"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how items within the box are aligned at the XL breakpoint.
          * @defaultValue stretch
         */
        "alignItemsXl"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how items within the box are aligned at the XS breakpoint.
          * @defaultValue stretch
         */
        "alignItemsXs"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container.
          * @defaultValue stretch
         */
        "alignSelf"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container at the LG breakpoint.
         */
        "alignSelfLg"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container at the MD breakpoint.
         */
        "alignSelfMd"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container at the SM breakpoint.
         */
        "alignSelfSm"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container at the XL breakpoint.
         */
        "alignSelfXl"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * Defines how the box is aligned within its container at the XS breakpoint.
         */
        "alignSelfXs"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * If `true`, the box will be sized to fit its contents.
         */
        "auto"?: boolean;
        /**
          * If `true`, the box will be sized to fit its contents at the LG breakpoint.
         */
        "autoLg"?: boolean;
        /**
          * If `true`, the box will be sized to fit its contents at the MD breakpoint.
         */
        "autoMd"?: boolean;
        /**
          * If `true`, the box will be sized to fit its contents at the SM breakpoint.
         */
        "autoSm"?: boolean;
        /**
          * If `true`, the box will be sized to fit its contents at the XL breakpoint.
         */
        "autoXl"?: boolean;
        /**
          * If `true`, the box will be sized to fit its contents at the XS breakpoint.
         */
        "autoXs"?: boolean;
        /**
          * Defines the background-color of the box.
         */
        "backgroundColor"?: string;
        /**
          * If `true`, the box will have a border.
          * @default false
         */
        "border"?: boolean;
        /**
          * Defines the border color of the box.
         */
        "borderColor"?: string;
        /**
          * Defines how rounded the box corners are.
          * @defaultValue none
         */
        "borderRadius"?: `none` | `xs`| `sm` | `md` | `lg` | `circle`;
        /**
          * Defines the orientation of the box items.
          * @defaultValue row
         */
        "direction"?: `row` | `column`;
        /**
          * Defines the display style of the box.
          * @defaultValue flex
         */
        "display"?: `flex` | `inline-flex` | `block` | `inline-block`;
        /**
          * If `true`, sets the box `max-width` to `100%`.
         */
        "fit"?: boolean;
        /**
          * If `true`, sets the box `max-width` to `100%` at the LG breakpoint.
         */
        "fitLg"?: boolean;
        /**
          * If `true`, sets the box `max-width` to `100%` at the MD breakpoint.
         */
        "fitMd"?: boolean;
        /**
          * If `true`, sets the box `max-width` to `100%` at the SM breakpoint.
         */
        "fitSm"?: boolean;
        /**
          * If `true`, sets the box `max-width` to `100%` at the XL breakpoint.
         */
        "fitXl"?: boolean;
        /**
          * If `true`, sets the box `max-width` to `100%` at the XS breakpoint.
         */
        "fitXs"?: boolean;
        /**
          * Defines how a box will grow or shrink to fit the space available in its container. Can be a predefined value ('none', 'grow', 'shrink') or a custom flex value (e.g., '1', '0 1 auto').
          * @defaultValue none
         */
        "flex"?: `none` | `grow` | `shrink` | string;
        /**
          * Defines the spacing between the box items.
          * @defaultValue none
         */
        "gap"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the LG breakpoint.
          * @defaultValue none
         */
        "gapLg"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the MD breakpoint.
          * @defaultValue none
         */
        "gapMd"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the SM breakpoint.
          * @defaultValue none
         */
        "gapSm"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the XL breakpoint.
          * @defaultValue none
         */
        "gapXl"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the XS breakpoint.
          * @defaultValue none
         */
        "gapXs"?: BoxSpacingType;
        /**
          * Defines the horizontal alignment of the box items.
          * @defaultValue start
         */
        "justifyContent"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the horizontal alignment of the box items at the LG breakpoint.
          * @defaultValue start
         */
        "justifyContentLg"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the horizontal alignment of the box items at the MD breakpoint.
          * @defaultValue start
         */
        "justifyContentMd"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the horizontal alignment of the box items at the SM breakpoint.
          * @defaultValue start
         */
        "justifyContentSm"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the horizontal alignment of the box items at the XL breakpoint.
          * @defaultValue start
         */
        "justifyContentXl"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the horizontal alignment of the box items at the XS breakpoint.
          * @defaultValue start
         */
        "justifyContentXs"?: `start` | `center` | `end` | `space-between` | `space-around` | `space-evenly`;
        /**
          * Defines the box's outer bottom spacing.
          * @defaultValue none
         */
        "marginBlockEnd"?: BoxSpacingType;
        /**
          * Defines the box's outer bottom spacing at the LG breakpoint.
          * @defaultValue none
         */
        "marginBlockEndLg"?: BoxSpacingType;
        /**
          * Defines the box's outer bottom spacing at the MD breakpoint.
          * @defaultValue none
         */
        "marginBlockEndMd"?: BoxSpacingType;
        /**
          * Defines the box's outer bottom spacing at the SM breakpoint.
          * @defaultValue none
         */
        "marginBlockEndSm"?: BoxSpacingType;
        /**
          * Defines the box's outer bottom spacing at the XL breakpoint.
          * @defaultValue none
         */
        "marginBlockEndXl"?: BoxSpacingType;
        /**
          * Defines the box's outer bottom spacing at the XS breakpoint.
          * @defaultValue none
         */
        "marginBlockEndXs"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing.
          * @defaultValue none
         */
        "marginBlockStart"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing at the LG breakpoint.
          * @defaultValue none
         */
        "marginBlockStartLg"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing at the MD breakpoint.
          * @defaultValue none
         */
        "marginBlockStartMd"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing at the SM breakpoint.
          * @defaultValue none
         */
        "marginBlockStartSm"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing at the XL breakpoint.
          * @defaultValue none
         */
        "marginBlockStartXl"?: BoxSpacingType;
        /**
          * Defines the box's outer top spacing at the XS breakpoint.
          * @defaultValue none
         */
        "marginBlockStartXs"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing.
          * @defaultValue none
         */
        "marginInlineEnd"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing at the LG breakpoint.
          * @defaultValue none
         */
        "marginInlineEndLg"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing at the MD breakpoint.
          * @defaultValue none
         */
        "marginInlineEndMd"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing at the SM breakpoint.
          * @defaultValue none
         */
        "marginInlineEndSm"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing at the XL breakpoint.
          * @defaultValue none
         */
        "marginInlineEndXl"?: BoxSpacingType;
        /**
          * Defines the box's outer right spacing at the XS breakpoint.
          * @defaultValue none
         */
        "marginInlineEndXs"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing.
          * @defaultValue none
         */
        "marginInlineStart"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing at the LG breakpoint.
          * @defaultValue none
         */
        "marginInlineStartLg"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing at the MD breakpoint.
          * @defaultValue none
         */
        "marginInlineStartMd"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing at the SM breakpoint.
          * @defaultValue none
         */
        "marginInlineStartSm"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing at the XL breakpoint.
          * @defaultValue none
         */
        "marginInlineStartXl"?: BoxSpacingType;
        /**
          * Defines the box's outer left spacing at the XS breakpoint.
          * @defaultValue none
         */
        "marginInlineStartXs"?: BoxSpacingType;
        /**
          * The minimum height of the row. Used in conjunction with alignment props
         */
        "minHeight"?: string;
        /**
          * The minimum width of the row. Used in conjunction with alignment props
         */
        "minWidth"?: string;
        /**
          * Move columns to the end direction of the row for all screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offset"?: BoxColumnType;
        /**
          * Move columns to the end direction of the row for `LG` screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offsetLg"?: BoxColumnType;
        /**
          * Move columns to the end direction of the row for `MD` screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offsetMd"?: BoxColumnType;
        /**
          * Move columns to the end direction of the row for `SM` screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offsetSm"?: BoxColumnType;
        /**
          * Move columns to the end direction of the row for `XL` screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offsetXl"?: BoxColumnType;
        /**
          * Move columns to the end direction of the row for `XS` screen sizes. Increases the starting margin of a column by specified number of columns.
         */
        "offsetXs"?: BoxColumnType;
        /**
          * Defines the spacing between the box items.
          * @defaultValue none
         */
        "padding"?: BoxSpacingType;
        /**
          * Defines the bottom spacing.
          * @defaultValue none
         */
        "paddingBlockEnd"?: BoxSpacingType;
        /**
          * Defines the bottom spacing at the LG breakpoint.
          * @defaultValue none
         */
        "paddingBlockEndLg"?: BoxSpacingType;
        /**
          * Defines the bottom spacing at the MD breakpoint.
          * @defaultValue none
         */
        "paddingBlockEndMd"?: BoxSpacingType;
        /**
          * Defines the bottom spacing at the SM breakpoint.
          * @defaultValue none
         */
        "paddingBlockEndSm"?: BoxSpacingType;
        /**
          * Defines the bottom spacing at the XL breakpoint.
          * @defaultValue none
         */
        "paddingBlockEndXl"?: BoxSpacingType;
        /**
          * Defines the bottom spacing at the XS breakpoint.
          * @defaultValue none
         */
        "paddingBlockEndXs"?: BoxSpacingType;
        /**
          * Defines the top spacing.
          * @defaultValue none
         */
        "paddingBlockStart"?: BoxSpacingType;
        /**
          * Defines the top spacing at the LG breakpoint.
          * @defaultValue none
         */
        "paddingBlockStartLg"?: BoxSpacingType;
        /**
          * Defines the top spacing at the MD breakpoint.
          * @defaultValue none
         */
        "paddingBlockStartMd"?: BoxSpacingType;
        /**
          * Defines the top spacing at the SM breakpoint.
          * @defaultValue none
         */
        "paddingBlockStartSm"?: BoxSpacingType;
        /**
          * Defines the top spacing at the XL breakpoint.
          * @defaultValue none
         */
        "paddingBlockStartXl"?: BoxSpacingType;
        /**
          * Defines the top spacing at the XS breakpoint.
          * @defaultValue none
         */
        "paddingBlockStartXs"?: BoxSpacingType;
        /**
          * Defines the right spacing.
          * @defaultValue none
         */
        "paddingInlineEnd"?: BoxSpacingType;
        /**
          * Defines the right spacing at the LG breakpoint.
          * @defaultValue none
         */
        "paddingInlineEndLg"?: BoxSpacingType;
        /**
          * Defines the right spacing at the MD breakpoint.
          * @defaultValue none
         */
        "paddingInlineEndMd"?: BoxSpacingType;
        /**
          * Defines the right spacing at the SM breakpoint.
          * @defaultValue none
         */
        "paddingInlineEndSm"?: BoxSpacingType;
        /**
          * Defines the right spacing at the XL breakpoint.
          * @defaultValue none
         */
        "paddingInlineEndXl"?: BoxSpacingType;
        /**
          * Defines the right spacing at the XS breakpoint.
          * @defaultValue none
         */
        "paddingInlineEndXs"?: BoxSpacingType;
        /**
          * Defines the left spacing.
          * @defaultValue none
         */
        "paddingInlineStart"?: BoxSpacingType;
        /**
          * Defines the left spacing at the LG breakpoint.
          * @defaultValue none
         */
        "paddingInlineStartLg"?: BoxSpacingType;
        /**
          * Defines the left spacing at the MD breakpoint.
          * @defaultValue none
         */
        "paddingInlineStartMd"?: BoxSpacingType;
        /**
          * Defines the left spacing at the SM breakpoint.
          * @defaultValue none
         */
        "paddingInlineStartSm"?: BoxSpacingType;
        /**
          * Defines the left spacing at the XL breakpoint.
          * @defaultValue none
         */
        "paddingInlineStartXl"?: BoxSpacingType;
        /**
          * Defines the left spacing at the XS breakpoint.
          * @defaultValue none
         */
        "paddingInlineStartXs"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the LG breakpoint.
          * @defaultValue none
         */
        "paddingLg"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the MD breakpoint.
          * @defaultValue none
         */
        "paddingMd"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the SM breakpoint.
          * @defaultValue none
         */
        "paddingSm"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the XL breakpoint.
          * @defaultValue none
         */
        "paddingXl"?: BoxSpacingType;
        /**
          * Defines the spacing between the box items at the XS breakpoint.
          * @defaultValue none
         */
        "paddingXs"?: BoxSpacingType;
        /**
          * Defines the box shadow.
          * @defaultValue none
         */
        "shadow"?: BoxShadowSizeType;
        /**
          * Sets the default column width for the component. This value applies from the smallest screen size (XS) upwards, unless overridden by a breakpoint-specific size prop at that breakpoint or larger.
         */
        "size"?: BoxColumnType;
        /**
          * At screen sizes from the LG breakpoint and larger (992px and up), this will take the specified number of columns. This overrides any value set by size, sizeXs, and up.
         */
        "sizeLg"?: BoxColumnType;
        /**
          * At screen sizes from the MD breakpoint and larger (768px and up), this will take the specified number of columns. This overrides any value set by size, sizeXs, and up.
         */
        "sizeMd"?: BoxColumnType;
        /**
          * At screen sizes from the SM breakpoint and larger (576px and up), this will take the specified number of columns. This overrides any value set by size or sizeXs.
         */
        "sizeSm"?: BoxColumnType;
        /**
          * At screen sizes from the XL breakpoint and larger (1200px and up), this will take the specified number of columns. This overrides any value set by size, sizeXs, and up.
         */
        "sizeXl"?: BoxColumnType;
        /**
          * At the XS breakpoint, this prop will take the number of columns specified. This overrides the base size prop for this specific range.
         */
        "sizeXs"?: BoxColumnType;
        /**
          * Defines whether flex items are forced onto one line or can wrap onto multiple lines.
          * @defaultValue false
         */
        "wrap"?: boolean;
        /**
          * Defines whether flex items can wrap onto multiple lines at the LG breakpoint.
          * @defaultValue false
         */
        "wrapLg"?: boolean;
        /**
          * Defines whether flex items can wrap onto multiple lines at the MD breakpoint.
          * @defaultValue false
         */
        "wrapMd"?: boolean;
        /**
          * Defines whether flex items can wrap onto multiple lines at the SM breakpoint.
          * @defaultValue false
         */
        "wrapSm"?: boolean;
        /**
          * Defines whether flex items can wrap onto multiple lines at the XL breakpoint.
          * @defaultValue false
         */
        "wrapXl"?: boolean;
        /**
          * Defines whether flex items can wrap onto multiple lines at the XS breakpoint.
          * @defaultValue false
         */
        "wrapXs"?: boolean;
    }
    interface PdsButton {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * Determines the button's disabled state.
          * @defaultValue false
         */
        "disabled"?: boolean;
        /**
          * Determines if the button should take up the full width of its container.
          * @defaultValue false
         */
        "fullWidth"?: boolean;
        /**
          * If provided, renders the component as an anchor (`<a>`) element instead of a button. When using href, button-specific props (type, name, value, loading) will be ignored.
         */
        "href"?: string;
        /**
          * Displays a leading icon in the button. DEPRECATED.
          * @defaultValue null
          * @deprecated Use `start` slot instead.
         */
        "icon"?: string;
        /**
          * When true, displays only the icon and visually hides the text (keeping it accessible).
          * @default false
         */
        "iconOnly"?: boolean;
        /**
          * Determines if the button is in a loading state. When true, displays a loader and hides the button text.
          * @defaultValue false
         */
        "loading"?: boolean;
        /**
          * Provides the button with a submittable name.
         */
        "name"?: string;
        "onPdsClick"?: (event: PdsButtonCustomEvent<any>) => void;
        /**
          * Specifies where to open the linked document when href is provided. Only applies when href is set.
         */
        "target"?: '_blank' | '_self' | '_parent' | '_top';
        /**
          * Provides button with a type.
          * @defaultValue button
         */
        "type"?: 'button' | 'reset' | 'submit';
        /**
          * Provides button with a submittable value
         */
        "value"?: string;
        /**
          * Sets the style variant of the button.
          * @defaultValue primary
         */
        "variant"?: 'primary' | 'secondary' | 'accent' | 'disclosure' | 'destructive' | 'unstyled' | 'filter';
    }
    interface PdsCheckbox {
        /**
          * It determines whether or not the checkbox is checked.
          * @default false
         */
        "checked"?: boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute and the label `for` attribute.
         */
        "componentId": string;
        /**
          * It determines whether or not the checkbox is disabled.
         */
        "disabled"?: boolean;
        /**
          * Displays message text describing an invalid state.
         */
        "errorMessage"?: string;
        /**
          * String used for helper message below checkbox.
         */
        "helperMessage"?: string;
        /**
          * Visually hides the label text for instances where only the checkbox should be displayed. Label remains accessible to assistive technology such as screen readers.
         */
        "hideLabel"?: boolean;
        /**
          * If `true`, the checkbox will visually appear as indeterminate. Only JavaScript can set the objects `indeterminate` property. See [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#indeterminate_state_checkboxes).
         */
        "indeterminate"?: boolean;
        /**
          * It determines whether or not the checkbox is invalid.
         */
        "invalid"?: boolean;
        /**
          * String used for label text next to checkbox.
         */
        "label"?: string;
        /**
          * String used for checkbox `name` attribute.
         */
        "name"?: string;
        /**
          * Event emitted that contains the `value` and `checked`.
         */
        "onPdsCheckboxChange"?: (event: PdsCheckboxCustomEvent<CheckboxChangeEventDetail>) => void;
        "onPdsCheckboxInput"?: (event: PdsCheckboxCustomEvent<CheckboxChangeEventDetail>) => void;
        /**
          * It determines whether or not the checkbox is required.
         */
        "required"?: boolean;
        /**
          * The value of the checkbox that is submitted with a form.
         */
        "value"?: string;
    }
    interface PdsChip {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * Determines whether a dot should be displayed on the chip. Note: This prop is ignored when sentiment is 'brand'.
          * @defaultValue false
         */
        "dot"?: boolean;
        /**
          * The name of the icon to display before the chip text.
         */
        "icon"?: string;
        /**
          * Determines whether the chip should be displayed in a larger size.
          * @defaultValue false
         */
        "large"?: boolean;
        /**
          * Event emitted when the close button is clicked on a tag variant chip.
         */
        "onPdsTagCloseClick"?: (event: PdsChipCustomEvent<any>) => void;
        /**
          * Defines the color scheme of the chip.
          * @defaultValue 'neutral'
         */
        "sentiment"?: ChipSentimentType;
        /**
          * Sets the style variant of the chip. Note: This prop is ignored when sentiment is 'brand'.
          * @defaultValue 'text'
         */
        "variant"?: ChipVariantType;
    }
    interface PdsCombobox {
        /**
          * Whether a dot should be displayed on the chip trigger.
          * @default false
         */
        "chipDot"?: boolean;
        /**
          * The name of the icon to display in the chip trigger.
         */
        "chipIcon"?: string;
        /**
          * Whether the chip trigger should be displayed in a larger size.
          * @default false
         */
        "chipLarge"?: boolean;
        /**
          * The sentiment for the chip trigger. Matches Pine chip sentiments.
          * @default 'neutral'
         */
        "chipSentiment"?: ChipSentimentType;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Enable custom layout content for options. Options with data-layout attribute will render their HTML content. ⚠️ Security Warning: Only use with trusted content. Basic XSS protection is applied, but avoid user-generated content.
          * @default false
         */
        "customOptionLayouts"?: boolean;
        /**
          * Enable custom layout content for the button trigger via the trigger-content slot. When true, uses slot content for initial state but updates dynamically with selected option layout. ⚠️ Security Warning: Only use with trusted content. Basic XSS protection is applied, but avoid user-generated content.
          * @default false
         */
        "customTriggerContent"?: boolean;
        /**
          * If true, the combobox is disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Placement of the dropdown relative to the trigger.
          * @default 'bottom-start'
         */
        "dropdownPlacement"?: 'bottom-start' | 'bottom-end' | 'top-start' | 'top-end';
        /**
          * Width of the dropdown. Any valid CSS width value.
          * @default '236px'
         */
        "dropdownWidth"?: string;
        /**
          * Visually hides the label text for instances where only the combobox should be displayed. Label remains accessible to assistive technology such as screen readers.
          * @default false
         */
        "hideLabel"?: boolean;
        /**
          * Text to be displayed as the combobox label.
         */
        "label"?: string;
        /**
          * Maximum height of the dropdown. Can be any valid CSS height value (e.g., '200px', '10rem'). When content exceeds this height, the dropdown will scroll.
         */
        "maxHeight"?: string;
        /**
          * Determines the combobox mode: 'filter' (filter options as you type) or 'select-only' (show all options).
          * @default 'filter'
         */
        "mode"?: 'filter' | 'select-only';
        /**
          * The name of the form control. Submitted with the form as part of a name/value pair.
         */
        "name"?: string;
        /**
          * Emitted when the value changes.
         */
        "onPdsComboboxChange"?: (event: PdsComboboxCustomEvent<{ value: string }>) => void;
        /**
          * Placeholder text for the input field.
         */
        "placeholder"?: string;
        /**
          * Determines the combobox trigger: 'input' (editable input), 'button' (button-like, non-editable), or 'chip' (chip-like, non-editable).
          * @default 'input'
         */
        "trigger"?: 'input' | 'button' | 'chip';
        /**
          * The visual variant for the button trigger. Matches Pine button variants.
          * @default 'secondary'
         */
        "triggerVariant"?: 'secondary' | 'primary' | 'accent' | 'destructive';
        /**
          * Width of the trigger (button or input). Any valid CSS width value.
          * @default 'fit-content'
         */
        "triggerWidth"?: string;
        /**
          * The value of the combobox input.
          * @default ''
         */
        "value"?: string;
    }
    interface PdsCopytext {
        /**
          * Determines whether `copytext` should have a visible border.
          * @defaultValue true
         */
        "border"?: boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * Determines whether `copytext` should expand to the full width of its container.
          * @defaultValue false
         */
        "fullWidth"?: boolean;
        /**
          * Event fired when copyText button is clicked.
         */
        "onPdsCopyTextClick"?: (event: PdsCopytextCustomEvent<any>) => void;
        /**
          * Determines whether the `value` should truncate and display with an ellipsis.
          * @defaultValue false
         */
        "truncate"?: boolean;
        /**
          * The string displayed that is also copied to the clipboard upon interaction.
         */
        "value": string;
    }
    interface PdsDivider {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * Adds offset margin/padding to expand the width (horizontal) or the height (vertical) of divider.
         */
        "offset"?: 'xxs' | 'xs' | 'sm' | 'md' | 'lg' | 'xl' | 'xxl';
        /**
          * Sets divider to display vertically.
          * @defaultValue false
         */
        "vertical"?: boolean;
    }
    interface PdsDropdownMenu {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * The placement of the dropdown panel relative to the trigger.
          * @default 'bottom-start'
         */
        "placement"?: PlacementType;
    }
    interface PdsDropdownMenuItem {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * It determines whether or not the dropdown-item is destructive.
          * @defaultValue false
         */
        "destructive"?: boolean;
        /**
          * It determines whether or not the dropdown-item is disabled.
          * @defaultValue false
         */
        "disabled"?: boolean;
        /**
          * If provided, renders the dropdown-item as an anchor (`<a>`) element instead of a button.
         */
        "href"?: string | undefined;
        /**
          * Emitted when the dropdown-item is clicked.
         */
        "onPdsClick"?: (event: PdsDropdownMenuItemCustomEvent<{itemIndex: number, item: HTMLPdsDropdownMenuItemElement, content: string}>) => void;
    }
    interface PdsDropdownMenuSeparator {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * It determines whether or not the dropdown-item is disabled.
          * @defaultValue false
         */
        "disabled"?: boolean;
    }
    /**
     * Individual filter component with cross-browser popover positioning.
     * Uses a hybrid approach for optimal cross-browser compatibility:
     * - Modern browsers: CSS anchor positioning + JavaScript flip classes
     * - Fallback browsers: JavaScript positioning with viewport boundary detection
     */
    interface PdsFilter {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * The name of the icon to display in the trigger button. For 'clear' variant, this is ignored as it always shows trash icon.
         */
        "icon"?: string;
        /**
          * Event emitted when the clear variant is clicked.
         */
        "onPdsFilterClear"?: (event: PdsFilterCustomEvent<PdsFilterClearEventDetail>) => void;
        /**
          * Event emitted when the filter popover is closed.
         */
        "onPdsFilterClose"?: (event: PdsFilterCustomEvent<PdsFilterCloseEventDetail>) => void;
        /**
          * Event emitted when the filter popover is opened.
         */
        "onPdsFilterOpen"?: (event: PdsFilterCustomEvent<PdsFilterOpenEventDetail>) => void;
        /**
          * The text content displayed in the trigger button.
         */
        "text"?: string;
        /**
          * The variant style of the filter trigger.
          * @defaultValue 'default'
         */
        "variant"?: PdsFilterVariant;
    }
    interface PdsFilters {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
    }
    interface PdsImage {
        /**
          * The image's alt tag. If none is provided, it will default to an empty string, which is desired for decorative images.
          * @defaultValue ''
         */
        "alt"?: string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * The height of the image in pixels. Setting this will devote space in the layout to prevent layout shifts when the image is loaded.
         */
        "height"?: number;
        /**
          * Indicates how the browser should load the image.
          * @defaultValue eager
         */
        "loading"?: 'eager' | 'lazy';
        /**
          * Determines the intended display size of an image within certain breakpoints. Has no effect if `srcset` is not set or value has no width descriptor.
         */
        "sizes"?: string;
        /**
          * The image's source.
         */
        "src"?: string;
        /**
          * A set of image sources for the browser to use for responsiveness.
         */
        "srcset"?: string;
        /**
          * The width of the image in pixels. Setting this will devote space in the layout to prevent layout shifts when the image is loaded.
         */
        "width"?: number;
    }
    interface PdsInput {
        /**
          * Specifies if and how the browser provides `autocomplete` assistance for the field.
         */
        "autocomplete"?: string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Sets the number of milliseconds to wait before updating the value.
         */
        "debounce"?: number;
        /**
          * Determines whether or not the input field is disabled.
         */
        "disabled"?: boolean;
        /**
          * Specifies the error message and provides an error-themed treatment to the field.
         */
        "errorMessage"?: string;
        /**
          * Determines whether or not the input field takes full width of its container.
         */
        "fullWidth"?: boolean;
        /**
          * Displays a message or hint below the input field.
         */
        "helperMessage"?: string;
        /**
          * Visually hides the label text for instances where only the input should be displayed. Label remains accessible to assistive technology such as screen readers. Note: When true, the action slot is also hidden to maintain a minimal UI.
         */
        "hideLabel"?: boolean;
        /**
          * Determines whether or not the input field is invalid or throws an error.
         */
        "invalid"?: boolean;
        /**
          * Text to be displayed as the input label.
         */
        "label"?: string;
        /**
          * Specifies the maximum value for the input field.
         */
        "max"?: string;
        /**
          * Specifies the maximum number of characters allowed in the input field.
         */
        "maxlength"?: string;
        /**
          * Specifies the minimum value for the input field.
         */
        "min"?: string;
        /**
          * Specifies the minimum number of characters allowed in the input field.
         */
        "minlength"?: string;
        /**
          * Specifies the name. Submitted with the form name/value pair.
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onPdsBlur"?: (event: PdsInputCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the value has changed.  This event will not emit when programmatically setting the `value` property.
         */
        "onPdsChange"?: (event: PdsInputCustomEvent<InputChangeEventDetail>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onPdsFocus"?: (event: PdsInputCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurs.
         */
        "onPdsInput"?: (event: PdsInputCustomEvent<InputInputEventDetail>) => void;
        /**
          * Specifies the regular expression that the input value is checked against.
         */
        "pattern"?: string;
        /**
          * Specifies a short hint that describes the expected value of the input field.
         */
        "placeholder"?: string;
        /**
          * Determines whether or not the input field is readonly.
         */
        "readonly"?: boolean;
        /**
          * Determines whether or not the input field is required.
         */
        "required"?: boolean;
        /**
          * Works with the `min` and `max` attributes to define increments for the input field.
         */
        "step"?: string;
        /**
          * Determines the type of control that will be displayed `'email'`, `'number'`, `'password'`, `'tel'`, `'text'`, `'url'`
          * @defaultValue "text"
         */
        "type"?: string;
        /**
          * The value of the input.
          * @default ''
         */
        "value"?: string | number | null;
    }
    interface PdsLink {
        /**
          * Sets the link color.
         */
        "color"?: string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * Determines whether the link should open in a new tab.
          * @defaultValue false
         */
        "external"?: boolean;
        /**
          * The font size of the link's text.
          * @defaultValue lg
         */
        "fontSize"?: 'sm' | 'md' | 'lg';
        /**
          * The hyperlink's destination URL. If no text is provided in the custom slot, the href will be used.
         */
        "href": string;
        /**
          * Sets the link variant styles.
          * @defaultValue inline
         */
        "variant"?: 'inline' | 'plain';
    }
    interface PdsLoader {
        /**
          * If false, the loader will be hidden.
          * @default true
         */
        "isLoading"?: boolean;
        /**
          * Determines whether the loader should display a label.
          * @default false
         */
        "showLabel"?: boolean;
        /**
          * Sets the size of the spinner loader. Value can be preset or custom.
          * @default 'md'
         */
        "size"?: | 'xs' // 24px
  | 'sm' // 32px
  | 'md' // 48px
  | 'lg' // 64px
  | 'xl' // 80px
  | string;
        /**
          * Determines the type of loader.
          * @default 'spinner'
         */
        "variant"?: 'spinner' | 'typing';
    }
    interface PdsModal {
        /**
          * Whether the modal can be dismissed by clicking the backdrop
          * @default true
         */
        "backdropDismiss"?: boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * Emitted when the modal is closed
         */
        "onPdsModalClose"?: (event: PdsModalCustomEvent<void>) => void;
        /**
          * Emitted when the modal is opened
         */
        "onPdsModalOpen"?: (event: PdsModalCustomEvent<void>) => void;
        /**
          * Whether the modal is open
          * @default false
         */
        "open"?: boolean;
        /**
          * Whether the modal content should be scrollable
          * @default true
         */
        "scrollable"?: boolean;
        /**
          * The size of the modal
          * @default 'md'
         */
        "size"?: 'sm' | 'md' | 'lg' | 'fullscreen';
    }
    interface PdsModalContent {
        /**
          * The border style for the content area. When not explicitly set, automatically determined based on scroll state.
          * @default 'none'
         */
        "border"?: 'none' | 'both' | 'top' | 'bottom';
    }
    interface PdsModalFooter {
    }
    interface PdsModalHeader {
    }
    interface PdsPopover {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * Sets the maximum width of the popover content
          * @defaultValue 352
         */
        "maxWidth"?: number;
        /**
          * Emitted when the popover is closed
         */
        "onPdsPopoverClose"?: (event: PdsPopoverCustomEvent<PdsPopoverEventDetail>) => void;
        /**
          * Emitted when the popover is opened
         */
        "onPdsPopoverOpen"?: (event: PdsPopoverCustomEvent<PdsPopoverEventDetail>) => void;
        /**
          * Determines the preferred position of the popover
          * @defaultValue "right"
         */
        "placement"?: PlacementType;
        /**
          * Determines the action that triggers the popover. For manual popovers, the consumer is responsible for toggling this value.
          * @defaultValue "show"
         */
        "popoverTargetAction"?: 'show' | 'toggle' | 'hide';
        /**
          * Determines the type of popover. Auto popovers can be "light dismissed" by clicking outside of the popover. Manual popovers require the consumer to handle the visibility of the popover.
          * @default 'auto'
         */
        "popoverType"?: 'auto' | 'manual';
        /**
          * Text that appears on the trigger element
         */
        "text"?: string;
    }
    interface PdsProgress {
        /**
          * Determines whether or not progress is animated.
          * @defaultValue false
         */
        "animated"?: boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute and the label `for` attribute.
         */
        "componentId": string;
        /**
          * Sets the progress fill color. Accepts a color token or a [valid color value](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value).
          * @defaultValue 'var(--pine-color-blue-300)'
         */
        "fillColor"?: string;
        /**
          * String used for label text. Label is visually hidden but required for better accessibility.
         */
        "label": string;
        /**
          * Sets the progress fill pecentage and visually displayed when `show-percentage=true`.
          * @defaultValue 0
         */
        "percent"?: number;
        /**
          * Determines whether or not the percent value should be displayed as text.
          * @defaultValue false
         */
        "showPercent"?: boolean;
    }
    interface PdsProperty {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * The name of the icon to display before the property text.
          * @default 'star'
         */
        "icon"?: string;
    }
    interface PdsRadio {
        /**
          * Determines whether or not the radio is checked.
          * @defaultValue false
         */
        "checked"?: boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute and the label `for` attribute.
         */
        "componentId": string;
        /**
          * Determines whether or not the radio is disabled.
          * @defaultValue false
         */
        "disabled"?: boolean;
        /**
          * Displays error message text describing an invalid state.
         */
        "errorMessage"?: string;
        /**
          * Adds a border around the radio component for better visual separation.
          * @defaultValue false
         */
        "hasBorder"?: boolean;
        /**
          * Displays helper message text below radio.
         */
        "helperMessage"?: string;
        /**
          * Visually hides the label text for instances where only the radio should be displayed. Label remains accessible to assistive technology such as screen readers.
         */
        "hideLabel"?: boolean;
        /**
          * Determines whether or not the radio is invalid.
          * @defaultValue false
         */
        "invalid"?: boolean;
        /**
          * String used for label text next to radio.
         */
        "label"?: string;
        /**
          * String used for radio `name` attribute.
         */
        "name"?: string;
        /**
          * Emits a boolean indicating whether the radio is currently checked or unchecked.
         */
        "onPdsRadioChange"?: (event: PdsRadioCustomEvent<boolean>) => void;
        /**
          * Determines whether or not the radio is required.
          * @defaultValue false
         */
        "required"?: boolean;
        /**
          * The value of the radio that is submitted with a form.
         */
        "value"?: string;
    }
    interface PdsRow {
        /**
          * Defines the vertical alignment of the row items.
          * @defaultValue start
         */
        "alignItems"?: `start` | `center` | `end` | `baseline` | `stretch`;
        /**
          * If `true`, the row will have a border.
          * @default false
         */
        "border"?: boolean;
        /**
          * Defines the spacing between the row items.
         */
        "colGap"?: BoxSpacingType | null;
        /**
          * Defines the spacing between the row items vertically.
         */
        "colGapBlock"?: BoxSpacingType | null;
        /**
          * Defines the spacing between the row items horizontally.
         */
        "colGapInline"?: BoxSpacingType | null;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * Defines the horizontal alignment of the row items.
          * @defaultValue start
         */
        "justifyContent"?: `start` | `center` | `end` | `space-between` | `space-around`;
        /**
          * The minimum height of the row. Used in conjunction with alignment props
         */
        "minHeight"?: string;
        /**
          * If `true`, the row items will not wrap to the next line if horizontal space is not available.
          * @default false
         */
        "noWrap"?: boolean;
    }
    interface PdsSelect {
        /**
          * Specifies if and how the browser provides `autocomplete` assistance for the field.
         */
        "autocomplete"?: string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Indicates whether or not the select field is disabled.
          * @defaultValue false
         */
        "disabled"?: boolean;
        /**
          * Displays error message text describing an invalid state.
         */
        "errorMessage"?: string;
        /**
          * Displays helper message text below select.
         */
        "helperMessage"?: string;
        /**
          * Visually hides the label text for instances where only the select should be displayed. Label remains accessible to assistive technology such as screen readers. Note: When true, the action slot is also hidden to maintain a minimal UI.
         */
        "hideLabel"?: boolean;
        /**
          * Applies highlight styling to the select field.
         */
        "highlight"?: boolean;
        /**
          * Determines whether or not the select is invalid.
         */
        "invalid"?: boolean;
        /**
          * Text to be displayed as the select label.
         */
        "label"?: string;
        /**
          * Indicates whether multiple options can be selected.
          * @defaultValue false
         */
        "multiple"?: boolean;
        /**
          * Specifies the name. Submitted with the form name/value pair.
         */
        "name": string;
        /**
          * Emitted when a keyboard input occurs.
         */
        "onPdsSelectChange"?: (event: PdsSelectCustomEvent<InputEvent>) => void;
        /**
          * Indicates whether or not the select field is required.
          * @defaultValue false
         */
        "required"?: boolean;
        /**
          * The value(s) of the selected option(s).
         */
        "value"?: string | string[];
    }
    interface PdsSortable {
        /**
          * Determines whether `sortable` should have a border.
          * @defaultValue false
         */
        "border"?: boolean;
        /**
          * A unique identifier used for the sortable container `id` attribute.
         */
        "componentId": string;
        /**
          * Deternines whether `sortable` items should be divided with border.
          * @default false
         */
        "dividers"?: boolean;
        /**
          * Determines the grabbable area for the `pds-sortable-item`.
          * @default 'row'
         */
        "handleType"?: 'handle' | 'row';
        /**
          * Event emitted when a sortable item is moved.
         */
        "onPdsSortableItemMoved"?: (event: PdsSortableCustomEvent<any>) => void;
    }
    interface PdsSortableItem {
        /**
          * A unique identifier used for the sortable item `id` attribute.
         */
        "componentId"?: string;
        /**
          * Determines whether `sortable-item-actions` slot should be enabled.
          * @defaultValue false
         */
        "enableActions"?: boolean;
        /**
          * Determines whether `sortable-item` should have a handle.
          * @defaultValue false
         */
        "showHandle"?: boolean;
    }
    interface PdsSwitch {
        /**
          * Determines the input 'checked' state.
          * @default false
         */
        "checked"?: boolean;
        /**
          * A unique identifier used for the underlying component `id` attribute and the label `for` attribute.
         */
        "componentId": string;
        /**
          * Determines the input 'disabled' state, preventing user interaction.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Displays message text describing an invalid state.
         */
        "errorMessage"?: string;
        /**
          * Displays help text for additional description of an input.
         */
        "helperMessage"?: string;
        /**
          * Visually hides the label text for instances where only the switch should be displayed. Label remains accessible to assistive technology such as screen readers.
         */
        "hideLabel"?: boolean;
        /**
          * Determines the input 'invalid' state, signifying an error is present.
          * @default false
         */
        "invalid"?: boolean;
        /**
          * Displays text to describe the input.
         */
        "label": string;
        /**
          * Identifies form data and unifies a group of radio inputs for toggling a single property/value.
         */
        "name"?: string;
        /**
          * Emits an event on input change.
         */
        "onPdsSwitchChange"?: (event: PdsSwitchCustomEvent<InputEvent>) => void;
        /**
          * Determines the 'required' state of the input.
          * @default false
         */
        "required"?: boolean;
        /**
          * Provides input with a string submitted in form data.
         */
        "value"?: string;
    }
    interface PdsTab {
        "index"?: number;
        /**
          * Sets the related tab name, this name must match a `pds-tabpanel`'s tab name property
         */
        "name": string;
        "onPdsTabClick"?: (event: PdsTabCustomEvent<object>) => void;
        "parentComponentId"?: string;
        /**
          * @default false
         */
        "selected"?: boolean;
        "variant"?: string;
    }
    interface PdsTable {
        /**
          * Determines if the table displays with reduced table cell padding.
         */
        "compact"?: boolean;
        /**
          * A unique identifier used for the table `id` attribute.
         */
        "componentId": string;
        /**
          * Determines if the should display a fixed first column.
         */
        "fixedColumn"?: boolean;
        /**
          * Event that is emitted when the checkbox is clicked, carrying the rowIndex and selected value.
         */
        "onPdsTableSelect"?: (event: PdsTableCustomEvent<{ rowIndex: number; isSelected: boolean }>) => void;
        /**
          * Event that is emitted when the select all checkbox is clicked, carrying the selected value.
         */
        "onPdsTableSelectAll"?: (event: PdsTableCustomEvent<{ isSelected: boolean }>) => void;
        /**
          * Enables the table to be responsive by horizontally scrolling on smaller screens.
         */
        "responsive"?: boolean;
        /**
          * Determines if the table displays checkboxes for selectable rows.
         */
        "selectable"?: boolean;
    }
    interface PdsTableBody {
    }
    interface PdsTableCell {
        /**
          * Sets the text alignment within the cell.
         */
        "cellAlign"?: 'start' | 'center' | 'end' | 'justify';
        /**
          * Truncates content to a max width of 100px and adds an ellipsis.
         */
        "truncate"?: boolean;
    }
    interface PdsTableHead {
        /**
          * Determines if the select all checkbox is in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Determines if the table row is currently selected.
          * @defaultValue false
         */
        "isSelected"?: boolean;
        /**
          * Event that is emitted when the select all checkbox is clicked, carrying the selected value.
         */
        "onPdsTableSelectAll"?: (event: PdsTableHeadCustomEvent<{ isSelected: boolean }>) => void;
    }
    interface PdsTableHeadCell {
        /**
          * Sets the text alignment within the head cell.
         */
        "cellAlign"?: 'start' | 'center' | 'end' | 'justify';
        /**
          * Event emitted to signal that a table column header has been sorted, providing information about the sorted column's name and sorting direction.
         */
        "onPdsTableSort"?: (event: PdsTableHeadCellCustomEvent<{ column: string; direction: string }>) => void;
        /**
          * Determines whether the table column is sortable when set to `true`.
         */
        "sortable"?: boolean;
    }
    interface PdsTableRow {
        /**
          * Determines if the row selected is in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * Determines if the table row is currently selected.
         */
        "isSelected"?: boolean;
        /**
          * Event that is emitted when the checkbox is clicked, carrying the selected value.
         */
        "onPdsTableRowSelected"?: (event: PdsTableRowCustomEvent<{ rowIndex: number; isSelected: boolean; }>) => void;
    }
    interface PdsTabpanel {
        /**
          * Sets the related tab name, this name must match a `pds-tab`'s tab name property
         */
        "name": string;
        "parentComponentId"?: string;
        /**
          * @default false
         */
        "selected"?: boolean;
        "variant"?: string;
    }
    interface PdsTabs {
        "activeTabIndex"?: number;
        /**
          * Sets the starting active tab name and maintains the name as the component re-renders
         */
        "activeTabName": string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Sets the aria-label attached to the tablist element
         */
        "tablistLabel": string;
        /**
          * Sets tabs variant styles as outlined in Figma documentation
         */
        "variant": 'primary' | 'availability' | 'filter' | 'pill';
    }
    interface PdsText {
        /**
          * Sets the text alignment.
         */
        "align"?: 'start' | 'center' | 'end' | 'justify';
        /**
          * Sets the text color.
         */
        "color"?: string;
        /**
          * Sets the text decoration.
         */
        "decoration"?: | 'strikethrough'
  | 'underline-dotted';
        /**
          * Set the bottom margin for the text.
         */
        "gutter"?: | '2xl'
  | 'xl'
  | 'lg'
  | 'md'
  | 'sm'
  | 'xs'
  | '2xs';
        /**
          * If set or `true`, the text will be italic.
         */
        "italic"?: boolean;
        /**
          * Sets the font size.
         */
        "size"?: | '2xl'
  | 'xl'
  | 'lg'
  | 'md'
  | 'sm'
  | 'xs'
  | '2xs'
  | 'h1'
  | 'h2'
  | 'h3'
  | 'h4'
  | 'h5'
  | 'h6';
        /**
          * Determines what semantic text tag to render.
          * @default "p"
         */
        "tag"?: | 'h1'
  | 'h2'
  | 'h3'
  | 'h4'
  | 'h5'
  | 'h6'
  | 'p'
  | 'code'
  | 'pre'
  | 'strong'
  | 'em';
        /**
          * If set or `true`, the text will be truncated. Must add a `width` to the element.
         */
        "truncate"?: boolean;
        /**
          * Sets the font weight.
         */
        "weight"?: | 'extra-light'
  | 'light'
  | 'regular'
  | 'medium'
  | 'semibold'
  | 'bold';
    }
    interface PdsTextarea {
        /**
          * Specifies if and how the browser provides `autocomplete` assistance for the field.
         */
        "autocomplete"?: string;
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * The amount of time, in milliseconds, to wait to trigger the event after each keystroke.
         */
        "debounce"?: number;
        /**
          * Determines whether or not the textarea is disabled.
          * @defaultValue false
         */
        "disabled"?: boolean;
        /**
          * Displays an error message below the textarea field.
         */
        "errorMessage"?: string;
        /**
          * Displays a message or hint below the textarea field.
         */
        "helperMessage"?: string;
        /**
          * Visually hides the label text for instances where only the textarea should be displayed. Label remains accessible to assistive technology such as screen readers. Note: When true, the action slot is also hidden to maintain a minimal UI.
         */
        "hideLabel"?: boolean;
        /**
          * Determines whether or not the textarea is invalid or throws an error.
          * @defaultValue false
         */
        "invalid"?: boolean;
        /**
          * Text to be displayed as the textarea label.
         */
        "label"?: string;
        /**
          * Specifies the maximum number of characters allowed in the textarea. When set, displays a character counter.
         */
        "maxLength"?: number;
        /**
          * Specifies the name. Submitted with the form name/value pair. This value will mirror the componentId.
          * @default this.componentId
         */
        "name"?: string;
        /**
          * Emitted when the input loses focus.
         */
        "onPdsBlur"?: (event: PdsTextareaCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when the input has focus.
         */
        "onPdsFocus"?: (event: PdsTextareaCustomEvent<FocusEvent>) => void;
        /**
          * Emitted when a keyboard input occurs.  For elements that accept text input (`type=text`, `type=tel`, etc.), the interface is [`InputEvent`](https://developer.mozilla.org/en-US/docs/Web/API/InputEvent); for others, the interface is [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event). If the input is cleared on edit, the type is `null`.
         */
        "onPdsInput"?: (event: PdsTextareaCustomEvent<TextareaInputEventDetail>) => void;
        /**
          * Event emitted whenever the value of the textarea changes.  This event will not emit when programmatically setting the `value` property.
         */
        "onPdsTextareaChange"?: (event: PdsTextareaCustomEvent<TextareaChangeEventDetail>) => void;
        /**
          * Specifies a short hint that describes the expected value of the textarea.
         */
        "placeholder"?: string;
        /**
          * Determines whether or not the textarea is readonly.
          * @defaultValue false
         */
        "readonly"?: boolean;
        /**
          * Determines whether or not the textarea is required.
          * @defaultValue false
         */
        "required"?: boolean;
        /**
          * Sets number of rows of text visible without needing to scroll in the textarea.
         */
        "rows"?: number;
        /**
          * The value of the textarea.
          * @default ''
         */
        "value"?: string | null;
    }
    interface PdsToast {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId": string;
        /**
          * Whether the toast can be dismissed manually via the close button. Note: This only controls manual dismissal. Auto-dismissal via duration still applies.
          * @default true
         */
        "dismissible"?: boolean;
        /**
          * The duration in milliseconds to show the toast before auto-dismissing. Set to 0 to disable auto-dismiss.
          * @default 4500
         */
        "duration"?: number;
        /**
          * The name of the icon to display in the toast.
         */
        "icon"?: string;
        /**
          * Event emitted when the toast is dismissed, either manually or automatically.
         */
        "onPdsToastDismissed"?: (event: PdsToastCustomEvent<{ componentId?: string }>) => void;
        /**
          * The type of toast to display. - default: Grey background (default) - danger: Red background - loading: With spinner animation
          * @default 'default'
         */
        "type"?: 'default' | 'danger' | 'loading';
    }
    interface PdsTooltip {
        /**
          * A unique identifier used for the underlying component `id` attribute.
         */
        "componentId"?: string;
        /**
          * Content for the tooltip. If HTML is required, use the content slot
         */
        "content"?: string;
        /**
          * Determines whether or not the tooltip has an arrow
          * @defaultValue true
         */
        "hasArrow"?: boolean;
        /**
          * Enable this option when using the content slot
          * @defaultValue false
         */
        "htmlContent"?: boolean;
        /**
          * Sets the maximum width of the tooltip content
          * @defaultValue "352px"
         */
        "maxWidth"?: string;
        /**
          * Determines whether or not the tooltip is visible
          * @defaultValue false
         */
        "opened"?: boolean;
        /**
          * Determines the preferred position of the tooltip
          * @defaultValue "right"
         */
        "placement"?: PlacementType;
    }
    interface IntrinsicElements {
        "mock-pds-modal": MockPdsModal;
        "pds-accordion": PdsAccordion;
        "pds-alert": PdsAlert;
        "pds-avatar": PdsAvatar;
        "pds-box": PdsBox;
        "pds-button": PdsButton;
        "pds-checkbox": PdsCheckbox;
        "pds-chip": PdsChip;
        "pds-combobox": PdsCombobox;
        "pds-copytext": PdsCopytext;
        "pds-divider": PdsDivider;
        "pds-dropdown-menu": PdsDropdownMenu;
        "pds-dropdown-menu-item": PdsDropdownMenuItem;
        "pds-dropdown-menu-separator": PdsDropdownMenuSeparator;
        "pds-filter": PdsFilter;
        "pds-filters": PdsFilters;
        "pds-image": PdsImage;
        "pds-input": PdsInput;
        "pds-link": PdsLink;
        "pds-loader": PdsLoader;
        "pds-modal": PdsModal;
        "pds-modal-content": PdsModalContent;
        "pds-modal-footer": PdsModalFooter;
        "pds-modal-header": PdsModalHeader;
        "pds-popover": PdsPopover;
        "pds-progress": PdsProgress;
        "pds-property": PdsProperty;
        "pds-radio": PdsRadio;
        "pds-row": PdsRow;
        "pds-select": PdsSelect;
        "pds-sortable": PdsSortable;
        "pds-sortable-item": PdsSortableItem;
        "pds-switch": PdsSwitch;
        "pds-tab": PdsTab;
        "pds-table": PdsTable;
        "pds-table-body": PdsTableBody;
        "pds-table-cell": PdsTableCell;
        "pds-table-head": PdsTableHead;
        "pds-table-head-cell": PdsTableHeadCell;
        "pds-table-row": PdsTableRow;
        "pds-tabpanel": PdsTabpanel;
        "pds-tabs": PdsTabs;
        "pds-text": PdsText;
        "pds-textarea": PdsTextarea;
        "pds-toast": PdsToast;
        "pds-tooltip": PdsTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Mock PdsModal component for testing purposes
             * This component mimics the real PdsModal but without using the Popover API
             */
            "mock-pds-modal": LocalJSX.MockPdsModal & JSXBase.HTMLAttributes<HTMLMockPdsModalElement>;
            "pds-accordion": LocalJSX.PdsAccordion & JSXBase.HTMLAttributes<HTMLPdsAccordionElement>;
            "pds-alert": LocalJSX.PdsAlert & JSXBase.HTMLAttributes<HTMLPdsAlertElement>;
            "pds-avatar": LocalJSX.PdsAvatar & JSXBase.HTMLAttributes<HTMLPdsAvatarElement>;
            "pds-box": LocalJSX.PdsBox & JSXBase.HTMLAttributes<HTMLPdsBoxElement>;
            "pds-button": LocalJSX.PdsButton & JSXBase.HTMLAttributes<HTMLPdsButtonElement>;
            "pds-checkbox": LocalJSX.PdsCheckbox & JSXBase.HTMLAttributes<HTMLPdsCheckboxElement>;
            "pds-chip": LocalJSX.PdsChip & JSXBase.HTMLAttributes<HTMLPdsChipElement>;
            "pds-combobox": LocalJSX.PdsCombobox & JSXBase.HTMLAttributes<HTMLPdsComboboxElement>;
            "pds-copytext": LocalJSX.PdsCopytext & JSXBase.HTMLAttributes<HTMLPdsCopytextElement>;
            "pds-divider": LocalJSX.PdsDivider & JSXBase.HTMLAttributes<HTMLPdsDividerElement>;
            "pds-dropdown-menu": LocalJSX.PdsDropdownMenu & JSXBase.HTMLAttributes<HTMLPdsDropdownMenuElement>;
            "pds-dropdown-menu-item": LocalJSX.PdsDropdownMenuItem & JSXBase.HTMLAttributes<HTMLPdsDropdownMenuItemElement>;
            "pds-dropdown-menu-separator": LocalJSX.PdsDropdownMenuSeparator & JSXBase.HTMLAttributes<HTMLPdsDropdownMenuSeparatorElement>;
            /**
             * Individual filter component with cross-browser popover positioning.
             * Uses a hybrid approach for optimal cross-browser compatibility:
             * - Modern browsers: CSS anchor positioning + JavaScript flip classes
             * - Fallback browsers: JavaScript positioning with viewport boundary detection
             */
            "pds-filter": LocalJSX.PdsFilter & JSXBase.HTMLAttributes<HTMLPdsFilterElement>;
            "pds-filters": LocalJSX.PdsFilters & JSXBase.HTMLAttributes<HTMLPdsFiltersElement>;
            "pds-image": LocalJSX.PdsImage & JSXBase.HTMLAttributes<HTMLPdsImageElement>;
            "pds-input": LocalJSX.PdsInput & JSXBase.HTMLAttributes<HTMLPdsInputElement>;
            "pds-link": LocalJSX.PdsLink & JSXBase.HTMLAttributes<HTMLPdsLinkElement>;
            "pds-loader": LocalJSX.PdsLoader & JSXBase.HTMLAttributes<HTMLPdsLoaderElement>;
            "pds-modal": LocalJSX.PdsModal & JSXBase.HTMLAttributes<HTMLPdsModalElement>;
            "pds-modal-content": LocalJSX.PdsModalContent & JSXBase.HTMLAttributes<HTMLPdsModalContentElement>;
            "pds-modal-footer": LocalJSX.PdsModalFooter & JSXBase.HTMLAttributes<HTMLPdsModalFooterElement>;
            "pds-modal-header": LocalJSX.PdsModalHeader & JSXBase.HTMLAttributes<HTMLPdsModalHeaderElement>;
            "pds-popover": LocalJSX.PdsPopover & JSXBase.HTMLAttributes<HTMLPdsPopoverElement>;
            "pds-progress": LocalJSX.PdsProgress & JSXBase.HTMLAttributes<HTMLPdsProgressElement>;
            "pds-property": LocalJSX.PdsProperty & JSXBase.HTMLAttributes<HTMLPdsPropertyElement>;
            "pds-radio": LocalJSX.PdsRadio & JSXBase.HTMLAttributes<HTMLPdsRadioElement>;
            "pds-row": LocalJSX.PdsRow & JSXBase.HTMLAttributes<HTMLPdsRowElement>;
            "pds-select": LocalJSX.PdsSelect & JSXBase.HTMLAttributes<HTMLPdsSelectElement>;
            "pds-sortable": LocalJSX.PdsSortable & JSXBase.HTMLAttributes<HTMLPdsSortableElement>;
            "pds-sortable-item": LocalJSX.PdsSortableItem & JSXBase.HTMLAttributes<HTMLPdsSortableItemElement>;
            "pds-switch": LocalJSX.PdsSwitch & JSXBase.HTMLAttributes<HTMLPdsSwitchElement>;
            "pds-tab": LocalJSX.PdsTab & JSXBase.HTMLAttributes<HTMLPdsTabElement>;
            "pds-table": LocalJSX.PdsTable & JSXBase.HTMLAttributes<HTMLPdsTableElement>;
            "pds-table-body": LocalJSX.PdsTableBody & JSXBase.HTMLAttributes<HTMLPdsTableBodyElement>;
            "pds-table-cell": LocalJSX.PdsTableCell & JSXBase.HTMLAttributes<HTMLPdsTableCellElement>;
            "pds-table-head": LocalJSX.PdsTableHead & JSXBase.HTMLAttributes<HTMLPdsTableHeadElement>;
            "pds-table-head-cell": LocalJSX.PdsTableHeadCell & JSXBase.HTMLAttributes<HTMLPdsTableHeadCellElement>;
            "pds-table-row": LocalJSX.PdsTableRow & JSXBase.HTMLAttributes<HTMLPdsTableRowElement>;
            "pds-tabpanel": LocalJSX.PdsTabpanel & JSXBase.HTMLAttributes<HTMLPdsTabpanelElement>;
            "pds-tabs": LocalJSX.PdsTabs & JSXBase.HTMLAttributes<HTMLPdsTabsElement>;
            "pds-text": LocalJSX.PdsText & JSXBase.HTMLAttributes<HTMLPdsTextElement>;
            "pds-textarea": LocalJSX.PdsTextarea & JSXBase.HTMLAttributes<HTMLPdsTextareaElement>;
            "pds-toast": LocalJSX.PdsToast & JSXBase.HTMLAttributes<HTMLPdsToastElement>;
            "pds-tooltip": LocalJSX.PdsTooltip & JSXBase.HTMLAttributes<HTMLPdsTooltipElement>;
        }
    }
}
